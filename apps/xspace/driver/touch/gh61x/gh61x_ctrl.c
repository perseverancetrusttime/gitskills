/**
  ******************************************************************************
  * @file    gh61x_example.c
  * @author  William Zhou
  * @version V0.7.0
  * @brief   An example for integrating GH61X ctrl library.
  * @modification history
  *  Data                Name                  Description
  *  ================    ==================    =================================
  *   17-Nov.  -2018      William Zhou          Initial draft
  *   26-Mar.  -2019      William Zhou          1. add mass production interface;
  *                                             2. add handler for abnormal reset;
  *                                             3. add example for debugging by using Goodix Dongle;
  *                                             4. add macro definition for various scenarios;
  *                                             5. add function prototype that should be implemented by user.
  *   14-May.  -2019      William Zhou          1. add roundkey related processing;
  *    3-Jun.  -2019	  William Zhou          1. supports both gh61x and gh612;
  *   11-Jul.  -2019	  William Zhou          1. add command for selecting debug chip;
  *   19-Jul.  -2019	  William Zhou          1. separate gh611+gh612_example.c to gh61x_example.c and gh612_example.c;
  *												2. add SPP debug interface example;
  *												3. avoid repeatedly responding to up-slid/down-slide/long-press event;
  *												4. clean up code;
  *   21-Jul.  -2019	  William Zhou          1. clean up code;
  *   29-Aug.  -2019	  William Zhou          1. add retry handling for abnormal reset;
  *                                             2. add hal_get_gh61x_int_level interface for getting GH61x int level.
  *    4-Sep.  -2019	  William Zhou          1. set config array type to be const for saving RAM resources;
  *    9-Sep.  -2019	  William Zhou          1. add retry handling for GH61x starting failure;
  *   12-Oct.  -2019	  William Zhou          1. add main section calibration list writting & reading operation function prototype for backup solution;
  *                                             2. optimize to retry handling for GH61x starting failure;
  *   14-Oct.  -2019	  William Zhou          1. limit retry handling times for GH61x starting failure;(default to 5 times, change GH61X_START_RETRY_CNT_MAX as needed)
  *   27-Oct.  -2019      William Zhou          1. add __GH61X_SWITCH_CHANNEL_ENABLE__ macro for controlling software configuration accroding to whether GH61x channel switched 
  *                                             2. add example for checking whether GH61x is started or stoped by Goodix APP;
  *                                             3. add example for checking whether system is in MP mode;
  *                                             4. add GH61X reset pin level function prototype;
  *                                             5. disable handling for abnormal reset in MP mode;
  *                                             6. update GH61X_Ctrl_init function to adapt to lib-3.1.1;
  *   13-Nov.  -2019      William Zhou          1. add heartbeat checking;
  *                                             2. add MP handling for connecting to Goodix APP or MP tool;
  *                                             3. clean up code, simplify handling for exception , start or stop GH61x in application layer;
  *                                             4. check wearing or touchkey event validation by using GH61X_HasWearingOrTkEventDetected;
  *                                             5. add handling in super-mp-mode(super-mp-mode is different to mp-mode, host is able to get data directly in super-mp-mode);
  *   16-Dec.  -2019      William Zhou          1. add polling checking gh61x interrupt state;
  *   3-Jan.   -2020      William Zhou          1. cancel checking wearing or touchkey event validation by using GH61X_HasWearingOrTkEventDetected;
  *                                             2. add delaying 30ms after CH61X_Reset in GH61X_Ctrl_init;
  *   23-Feb.  -2020      William Zhou          1. add debugging mode for getting GH61x rawdata, see __HOST_MODE__ macro for detail;
  *                                             2. fix some grammatical mistake;
  *   23-Jul.  -2020      Zhifan Zhang          1. check wearing or touchkey event validation by using GH61X_HasWearingOrTkEventDetected;
  *                                             2. add some Log information and print in gh61x format;
  *                                             3. close host exti interrupt response before run GH61X_CommParseHandler() and recover;
  *                                             4. add functional interface for app mode to change the sample rate if needed by opening the macro __GH61X_SAMPLERATE_CONFIG__;
  *                                             5. add optional interface for registering host software version and bluetooth MAC information;
  *   14-Aug.  -2020      Zhifan Zhang          1. change the interface GH61X_GetVersion() and GH61X_GetRawData();
  *                                             2. add the solution of package message for spp communication;
  *                                             3. add the interface to configure the self-cali factors in charging box.
  *                                             4. add interface to configure normalization function when there is no int_num information in cali-list��
  *   12-Oct.  -2020      Zhifan Zhang          1. add __GH61X_FAST_CALIBRATION_ENABLE__ macro to control fast offset self-calibration in box;
  *                                             2. add 0x0150 register congiguration in g_gh61x_RegConfigArr[] to support whether host load patch when gh61x start in mcu mode;
  *                                             3. add handling in super-mp-mode(super-mp-mode is different to mp-mode, host is able to get data directly in super-mp-mode).
  *   20-Nov.  -2020      Zhifan Zhang          1. add optional configuration for delay time when send package after reading cali-list in mp mode;
  *                                             2. add debug information for offset-self-calibration in box. 
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2018 Goodix Inc. All rights reserved.
  *
  ******************************************************************************
  */
#if defined(__TOUCH_GH61X__)
#include "cmsis.h"
#include "hal_gpio.h"
#include "cmsis_os.h"
#include "hal_uart.h"
#include "hal_sleep.h"
#include "app_utils.h"
#include "hal_timer.h"
#include "hal_touch.h"
#include "hal_trace.h"
#include "gh61x_ctrl.h"
#include "gh61x_adapter.h"
#include "tgt_hardware.h"
#include "factory_section.h"
#include "xspace_i2c_master.h"

#include "xspace_flash_access.h"
#include "xspace_ram_access.h"
#include "xspace_interface.h"

#if defined(__XSPACE_UI__)
#if defined(__USE_HW_I2C__)
#define GH61X_I2C_TYPE (XSPACE_HW_I2C)
#elif defined(__USE_SW_I2C__)
#define GH61X_I2C_TYPE (XSPACE_SW_I2C)
#endif
#else
#define GH61X_I2C_TYPE (XSPACE_HW_I2C)
#endif

#define GH61X_FLASH_DATA_LENG 256

#define GH61X_EXAMPLE_LOG(...)                     //NRF_LOG_DEBUG("[GH61X]:" __VA_ARGS__)    // when needed print log, replace the NRF_LOG_DEBUG/NRF_LOG_HEXDUMP_DEBUG
#define GH61X_EXAMPLE_HEXDUMP_DEBUG(p_data, len)   //NRF_LOG_HEXDUMP_DEBUG(p_data, len)       // with the logging function in customer platform

#define DEBUG_CHIP_SELECTION_610     (0)
#define DEBUG_CHIP_SELECTION_611     (1)
#define DEBUG_CHIP_SELECTION_612     (2)
#define DEBUG_CHIP_SELECTION_INVALID (0xFF)

#define __GH61X_CHIP_SELECTION__                   (DEBUG_CHIP_SELECTION_610)   //change to DEBUG_CHIP_SELECTION_610 if the chip you are using is GH610
#define __GH61X_MASS_PRODUCTION_INTERFACE_ENABLE__ (1)                          //1: Flash read/write interface is needed for mass production.
#define __GH61X_FIRMWARE_PATCH_ENABLE__            (1)                          //force to be 1 since lib-3.1.1.
#define __GH61X_NEW_CONFIGURATION_ENABLE__         (1)                          //1: New configuration parameter is needed for application.
#define __GH61X_CALIBRATION_ENABLE__               (1)                          //1: Calibration parameter in flash is needed for application.
#define __GH61X_USE_RAM_SIMULATE_FLASH_ENABLE__                                 (0)   //1: Use ram section to store calibration parameter for decreasing Flash read/write times. 
          //   Only valid for system that host guarantee to read flash when system power on and write flash before system shut down.
#define __GH61X_SWITCH_CHANNEL_ENABLE__                  (0)   //1: GH61x channel switched in hardware.
#define __GH61X_INT_POLLING__                            (0)   //1: polling interrupt pin if host missing external interrupt.
#define __GH61X_SAMPLERATE_CONFIG__                      (0)   //1:configure the sample rate in app mode.
#define __GH61X_HOST_VERSION_REGISTER__                  (0)   //1: register the host software version to gh61x.
#define __GH61X_BLE_MAC_INFO_REGISTER__                  (1)   //1: register the bluetooth mac information to gh61x.
#define __GH61X_OFFSET_SELFCALIINBOX_CFG_FACTOR_ENABLE__ (0)   //1: enbale the function to configure the factor of self-cali in charging box
#define __GH61X_PACKAGE_SET_SPP_ENABLE__                 (1)   //1: package message due to spp overrun
#define __GH61X_NORMALIZATION_TARGET_SET_ENABLE__        (0)   //1: enable function:normalization if needed.
#define __GH61X_FAST_CALIBRATION_ENABLE__                (0)   //1: enable fast self-calibration if needed.
#define __GH61X_SUPER_MP_MODE_ENABLE__                   (0)   //1: enable super-mp-mode if needed.
#define __GH61X_READ_FLASH_DELAY_MP_MODE_ENABLE__        (0)   //1: enable configure delay time per frame when send package after reading flash in mp mode.
#define __GH61X_DEBUGINFO_OFFSETSELFCALI_ENABLE__        (0)   //1: enable to print debug information about offset self-calibration in box.

#define __GH61X_USE_GOODIX_APP_BY_BLE__     (0)
#define __GH61X_USE_GOODIX_APP_BY_SPP__     (1)
#define __GH61X_USE_GOODIX_DONGLE_BY_UART__ (1)

#define HOST_MODE_APPLICATION (0)
#define HOST_MODE_DEBUGGING   (1)   //debugging mode, rawdata valid in this mode.
#define __HOST_MODE__         (HOST_MODE_APPLICATION)

/******************************************************************************/
/*                             Common function list                           */
/******************************************************************************/
#ifndef __GH61X_COMMON_FUNCTION_DECLARE__
#define __GH61X_COMMON_FUNCTION_DECLARE__
void user_delay_ms(uint16_t Nms);

void user_i2c_init(void);
uint8_t user_i2c_write(uint8_t uchDeviceId, const uint8_t uchWriteBytesArr[], uint16_t usWriteLen);
uint8_t user_i2c_read(uint8_t uchDeviceId, const uint8_t uchCmddBytesArr[], uint16_t usCmddLen, uint8_t uchReadBytesArr[], uint16_t usMaxReadLen);

#if ((__GH61X_USE_GOODIX_APP_BY_BLE__) || (__GH612_USE_GOODIX_APP_BY_BLE__))
void user_ble_send_data(uint8_t uchDataBuffArr[], uint8_t uchLen);
void ble_rx_data_handler(uint8_t *buffer, uint8_t length);
#endif

#if ((__GH61X_USE_GOODIX_APP_BY_SPP__) || (__GH612_USE_GOODIX_APP_BY_SPP__))
void user_spp_send_data(uint8_t buf[], uint8_t len);
void spp_rx_data_handler(uint8_t *buffer, uint8_t length);
#endif

#if ((__GH61X_USE_GOODIX_DONGLE_BY_UART__) || (__GH612_USE_GOODIX_DONGLE_BY_UART__))
void user_uart_send_data(uint8_t buf[], uint8_t len);
uint8_t get_chip_selection_from_data_stream(uint8_t recv_byte);
void uart_rx_data_handler(uint8_t *buffer, uint8_t length);
#endif
#endif

/******************************************************************************/
/*                         GH61X related function list                        */
/******************************************************************************/
void hal_gh61x_reset_init(void);
void hal_gh61x_reset_high(void);
void hal_gh61x_reset_low(void);
uint8_t hal_get_gh61x_reset_level(void);
#if (__GH61X_MASS_PRODUCTION_INTERFACE_ENABLE__)
uint8_t user_gh61x_calibration_list_write(const uint8_t uchCalListArr[], uint16_t usWriteLen);
uint8_t user_gh61x_calibration_list_read(uint8_t uchReadBytesArr[], uint16_t usReadLen);
uint8_t user_gh61x_main_calibration_list_write(const uint8_t uchCalListArr[], uint16_t usWriteLen);
uint8_t user_gh61x_main_calibration_list_read(uint8_t uchReadBytesArr[], uint16_t usReadLen);

uint8_t user_gh61x_calibration_list_write_flash(const uint8_t uchCalListArr[], uint16_t usWriteLen);
uint8_t user_gh61x_calibration_list_read_flash(uint8_t uchReadBytesArr[], uint16_t usReadLen);
uint8_t user_gh61x_main_calibration_list_write_flash(const uint8_t uchCalListArr[], uint16_t usWriteLen);
uint8_t user_gh61x_main_calibration_list_read_flash(uint8_t uchReadBytesArr[], uint16_t usReadLen);

#if (__GH61X_USE_RAM_SIMULATE_FLASH_ENABLE__)
uint8_t user_gh61x_calibration_info_in_ram_main[64] = {0};
uint8_t user_gh61x_calibration_info_in_ram_backup[64] = {0};
#endif

#endif
void hal_gh61x_int_init(void);
void hal_gh61x_int_deinit(void);
void hal_gh61x_int_irq_enable(bool enable);
uint8_t hal_get_gh61x_int_level(void);
void gh61x_int_handler(enum HAL_GPIO_PIN_T pin);
int GH61X_Ctrl_init(void);
int8_t GH61X_Application_Start(void);
#ifdef __HOST_MODE__
void GH610_Debug_Start(void);
#endif
int8_t GH61X_Application_Stop(void);
void GH61X_Exception_Handling(void);
void GH61X_MP_Handling(void);

#if (__GH61X_NEW_CONFIGURATION_ENABLE__)
const unsigned char g_gh61x_RegConfigArr[];
#endif

#if (__GH61X_USE_GOODIX_APP_BY_BLE__)
uint8_t gh61x_ble_comm_type = 0xFF;
#endif

#if (__GH61X_USE_GOODIX_APP_BY_SPP__)
uint8_t gh61x_spp_comm_type = 0xFF;
#endif

#if (__GH61X_USE_GOODIX_DONGLE_BY_UART__)
uint8_t gh61x_uart_comm_type = 0xFF;
#endif

#ifndef __GH61X_DEBUG_CHIP_SELECTION__
#define __GH61X_DEBUG_CHIP_SELECTION__
#if (__GH61X_CHIP_SELECTION__ == DEBUG_CHIP_SELECTION_610)
uint8_t g_debug_chip_selection = DEBUG_CHIP_SELECTION_610;   //default to 610
#elif (__GH61X_CHIP_SELECTION__ == DEBUG_CHIP_SELECTION_611)
uint8_t g_debug_chip_selection = DEBUG_CHIP_SELECTION_611;   //default to 611
#endif
#endif

typedef enum {
    GH61X_WORK_STATE_STOPPED = 0,
    GH61X_WORK_STATE_STARTING,
    GH61X_WORK_STATE_STARTED,
} EM_GH61X_WORK_STATE_TYPE;

static EM_GH61X_WORK_STATE_TYPE gh61x_work_state = GH61X_WORK_STATE_STOPPED;

typedef enum {
    EARPHONE_SLEEP = 0,
    EARPHONE_STATE_OPEN_BOX,
    EARPHONE_STATE_TAKE_OUT_BOX,
    EARPHONE_STATE_PUT_IN_BOX,
    EARPHONE_STATE_CLOSE_BOX,
    EARPHONE_STATE_SHUT_DOWN,
    EARPHONE_STATE_ENTER_SUPER_MP_MODE,
    EARPHONE_STATE_GET_DATA_IN_SUPER_MP_MODE,
    EARPHONE_STATE_EXIT_SUPER_MP_MODE,
} EM_EARPHONE_STATE_TYPE;

//static EM_EARPHONE_STATE_TYPE g_earphone_state = EARPHONE_SLEEP;
//static uint8_t earphone_state_changed = 0;

#define GH61X_START_RETRY_CNT_MAX 5
static uint8_t g_gh61x_start_retry_cnt = 0;

static void user_gh61x_work_state_checker_timer_start(void);
static void user_gh61x_work_state_checker_timer_stop(void);
static void user_gh61x_work_state_checker_handler(void const *param);

#if __GH61X_INT_POLLING__
static void user_gh61x_int_polling_timer_start(void);
static void user_gh61x_int_polling_timer_stop(void);
static void user_gh61x_int_polling_handler(void const *param);

osTimerDef(GH61X_INT_POLLING_TIMER, user_gh61x_int_polling_handler);
static osTimerId gh61x_int_polling_timer = NULL;
#endif

static void gh61x_start_test_mode_timer_handler(void const *param);

osTimerDef(GH61X_WORK_STATE_CHECKER_TIMER, user_gh61x_work_state_checker_handler);
static osTimerId gh61x_work_state_checker = NULL;

#define GH61X_TIMER_DELAY (2000)

uint8_t g_IsGH61xPreInMpMode = 0;
uint8_t g_IsGH61xStartTestMode = 0;
uint8_t g_IsGH61xSppStartTestMode = 0;
static uint16_t g_IsGH61xStartTestModeCnt = 0;
osTimerDef(GH61X_START_TEST_MODE_TIMER, gh61x_start_test_mode_timer_handler);
static osTimerId gh61x_start_test_mode_timer = NULL;

#if 0   //Foolproof PATCH, prototypes without calibration in the foolproof version have no function.
const unsigned char GH61X_PATCH_ADDR[3086] =
{
	0x03,0x02,0x01,0x00,0x02,0x36,0x31,0x30,0x57,0xCE,0x3F,0x73,0xB3,0x19,0x69,0x2C,
	0x80,0xF8,0x0E,0x43,0x3D,0x40,0x00,0x04,0x0F,0x4E,0x0F,0x5F,0x0F,0x5D,0xBF,0x40,
	0x44,0xF4,0x00,0x00,0x1E,0x53,0x3E,0x90,0x19,0x00,0xF6,0x2B,0xB2,0x40,0xBA,0xF7,
	0x00,0x04,0xB2,0x40,0xF6,0xF7,0x06,0x04,0xB2,0x40,0x74,0xF8,0x16,0x04,0xB2,0x40,
	0x8C,0xF8,0x1C,0x04,0xB2,0x40,0x9A,0xF8,0x1E,0x04,0xB2,0x40,0xAA,0xF8,0x24,0x04,
	0x30,0x41,0x3F,0x40,0xFE,0x05,0x01,0x4F,0xB0,0x12,0x04,0xF4,0x32,0xC2,0xB2,0x43,
	0x84,0x03,0xB2,0x43,0x86,0x03,0x32,0xD2,0x30,0x40,0x60,0xF4,0x30,0x41,0x31,0x40,
	0xFE,0x05,0x82,0x43,0xA8,0x05,0xB0,0x12,0xBA,0xE2,0xB0,0x12,0x4E,0xE3,0xB0,0x12,
	0xAA,0xF6,0x92,0x43,0xA8,0x05,0xB0,0x12,0x10,0xE3,0x0F,0x93,0xFC,0x27,0x32,0xD0,
	0x10,0x00,0xF9,0x3F,0x30,0x40,0x34,0xF3,0x3F,0x40,0x01,0x09,0xB0,0x12,0xA0,0xE2,
	0x30,0x41,0x82,0x93,0x9C,0x05,0x07,0x24,0xB2,0x90,0x03,0x00,0x9C,0x05,0x05,0x20,
	0xB0,0x12,0x8A,0xF4,0x02,0x3C,0xB0,0x12,0x92,0xE2,0xB0,0x12,0x4E,0xFC,0x30,0x41,
	0xB0,0x12,0xD6,0xE9,0xB0,0x12,0xFE,0xFB,0xB2,0x90,0x20,0x03,0x86,0x01,0x02,0x20,
	0xB0,0x12,0xE8,0xFB,0xB2,0x40,0x5A,0xF5,0x34,0x04,0x30,0x41,0x0F,0x43,0xB0,0x12,
	0xFC,0xE2,0x92,0x43,0x88,0x03,0x92,0x43,0xF8,0x04,0x82,0x93,0x9C,0x05,0x01,0x24,
	0x30,0x41,0xB0,0x12,0xD6,0xE9,0xB0,0x12,0xFE,0xFB,0xB0,0x12,0x4E,0xFC,0xB0,0x12,
	0x8A,0xF4,0x1F,0x42,0x78,0x04,0xB0,0x12,0x26,0xE2,0xF2,0x3F,0x1F,0x43,0xB0,0x12,
	0xFC,0xE2,0x92,0x43,0x88,0x03,0x82,0x43,0xF8,0x04,0x82,0x93,0x9C,0x05,0x01,0x24,
	0x30,0x41,0xB0,0x12,0x92,0xE2,0xFC,0x3F,0x0B,0x12,0x0B,0x43,0x82,0x43,0x98,0x05,
	0xB2,0x40,0xAA,0x55,0xC2,0x04,0x3F,0x40,0x42,0x00,0xDF,0xC3,0x00,0x00,0xDF,0xD3,
	0x00,0x00,0xDF,0xC3,0x00,0x00,0xB2,0x90,0xAA,0x55,0xC2,0x04,0x0B,0x20,0x1F,0x43,
	0xB0,0x12,0x5E,0xE3,0x1B,0x53,0x3B,0x90,0x64,0x00,0xE7,0x2F,0xB2,0x90,0xAA,0x55,
	0xC2,0x04,0xF5,0x27,0x3B,0x41,0x30,0x41,0x0B,0x12,0x0A,0x12,0x09,0x12,0x08,0x12,
	0x07,0x12,0x06,0x12,0x05,0x12,0x04,0x12,0x0C,0x4F,0x35,0x40,0x00,0x02,0x82,0x93,
	0x9E,0x05,0x39,0x24,0x18,0x42,0x60,0x04,0x1E,0x42,0x42,0x00,0x3E,0xF0,0x0F,0xC0,
	0x1F,0x43,0x0D,0x4C,0x2D,0x52,0x0D,0x93,0x03,0x24,0x0F,0x5F,0x1D,0x83,0xFD,0x23,
	0x0E,0xDF,0x82,0x4E,0x42,0x00,0x09,0x4C,0x09,0x59,0x17,0x49,0x80,0x05,0x1A,0x42,
	0x5E,0x04,0x7A,0xF3,0x0A,0x93,0x22,0x24,0x0B,0x47,0x0B,0x55,0x12,0xC3,0x0B,0x10,
	0x89,0x4B,0x6C,0x00,0xB0,0x12,0x1A,0xF5,0x1F,0x49,0x96,0x00,0x0F,0x98,0x11,0x34,
	0x05,0x4B,0x0F,0x88,0xB0,0x12,0x74,0xE3,0x0E,0x4F,0x1F,0x42,0x5E,0x04,0x7F,0xF3,
	0x0A,0x9F,0x02,0x24,0x0E,0x96,0x02,0x2C,0x06,0x4E,0x04,0x4B,0x3A,0x53,0xE4,0x23,
	0x05,0x3C,0x07,0x4B,0xEE,0x3F,0x38,0x40,0x80,0x0C,0xC6,0x3F,0x89,0x44,0x6C,0x00,
	0x34,0x41,0x35,0x41,0x36,0x41,0x37,0x41,0x38,0x41,0x39,0x41,0x3A,0x41,0x3B,0x41,
	0x30,0x41,0xE2,0xD2,0x82,0x03,0xF2,0xD0,0x80,0xFF,0x43,0x00,0x2F,0x43,0xB0,0x12,
	0xB2,0xF1,0x1F,0x43,0xB0,0x12,0xB2,0xF1,0x0F,0x43,0xB0,0x12,0xB2,0xF1,0xF2,0xF0,
	0x7F,0x00,0x43,0x00,0x30,0x41,0x0E,0x4F,0x0E,0x5E,0x1F,0x4E,0x72,0x00,0x1F,0x5E,
	0x76,0x00,0x12,0xC3,0x0F,0x10,0x8E,0x4F,0x72,0x00,0x8E,0x4F,0x76,0x00,0x30,0x41,
	0x0F,0x43,0xB0,0x12,0x28,0xF6,0x1F,0x43,0xB0,0x12,0x28,0xF6,0x30,0x41,0x0E,0x4F,
	0x0E,0x5E,0xBE,0x90,0xA9,0x16,0x9C,0x00,0x04,0x2C,0xBE,0x90,0xA9,0x16,0xA0,0x00,
	0x0C,0x28,0x1F,0x4E,0x72,0x00,0x1F,0x53,0x3F,0x90,0xFF,0x01,0x05,0x2C,0x9E,0x53,
	0x72,0x00,0x9E,0x53,0x76,0x00,0x30,0x41,0x30,0x41,0xBE,0x90,0xFC,0x08,0x9C,0x00,
	0x04,0x28,0xBE,0x90,0xFC,0x08,0xA0,0x00,0xF7,0x2F,0xAE,0x93,0x72,0x00,0xF4,0x2B,
	0xBE,0x53,0x72,0x00,0xBE,0x53,0x76,0x00,0xEF,0x3F,0x0F,0x43,0xB0,0x12,0x50,0xF6,
	0x1F,0x43,0xB0,0x12,0x50,0xF6,0x30,0x41,0xF2,0xB0,0x40,0x00,0x1C,0x03,0x03,0x24,
	0xB0,0x12,0xDA,0xF6,0x30,0x41,0xB2,0x42,0x18,0x03,0x30,0x41,0x82,0x93,0x80,0x05,
	0x02,0x24,0x1F,0x43,0x30,0x41,0x0F,0x43,0x30,0x41,0xB2,0x93,0x8E,0x05,0x02,0x24,
	0x1F,0x43,0x30,0x41,0x0F,0x43,0x30,0x41,0xB0,0x12,0xB2,0xF4,0x82,0x43,0x92,0x05,
	0x82,0x43,0x94,0x05,0x82,0x43,0x96,0x05,0x5F,0x42,0x40,0x00,0x12,0xC3,0x4F,0x10,
	0x4F,0x11,0x4F,0x11,0x4F,0x11,0x7F,0xF3,0x1F,0x53,0x82,0x4F,0x9A,0x05,0x1F,0x42,
	0x40,0x04,0x3F,0xF0,0x00,0x0F,0x8F,0x10,0x7F,0xF3,0x82,0x4F,0x9C,0x05,0xB0,0x12,
	0xBE,0xF6,0x82,0x4F,0x9E,0x05,0xB0,0x12,0xBA,0xE2,0x82,0x43,0x88,0x03,0xB2,0x90,
	0x20,0x03,0x86,0x01,0x15,0x24,0xB0,0x12,0x04,0xF6,0x1F,0x42,0x78,0x04,0xB0,0x12,
	0x26,0xE2,0xE2,0xC2,0x82,0x03,0xD2,0xD3,0x42,0x00,0xB0,0x12,0xAC,0xE2,0xB2,0x90,
	0x03,0x00,0x9C,0x05,0x0F,0x20,0x1F,0x42,0x78,0x04,0xB0,0x12,0x26,0xE2,0x0A,0x3C,
	0xB0,0x12,0x94,0xF4,0xB0,0x12,0xB0,0xF2,0x82,0x93,0x9E,0x05,0xEA,0x27,0xB0,0x12,
	0x42,0xF6,0xE7,0x3F,0xB2,0x40,0x20,0x03,0x86,0x01,0xA2,0x42,0x18,0x03,0x30,0x41,
	0xB0,0x12,0x10,0xE3,0x0F,0x93,0x01,0x20,0x30,0x41,0xB0,0x12,0x24,0xE3,0x0F,0x93,
	0xFB,0x27,0x82,0x43,0x88,0x03,0xF2,0xD0,0x20,0x00,0x18,0x03,0xF5,0x3F,0xB0,0x12,
	0x5A,0xFB,0x1F,0x42,0xF8,0x04,0x0F,0x93,0x03,0x20,0x92,0x93,0xF6,0x04,0x09,0x24,
	0x1F,0x93,0x01,0x24,0x30,0x41,0x82,0x93,0xF6,0x04,0xFC,0x23,0xB0,0x12,0xFE,0xF4,
	0xF9,0x3F,0xB0,0x12,0xCE,0xF4,0x30,0x41,0x82,0x93,0x9E,0x05,0x18,0x20,0xB2,0x90,
	0x03,0x00,0x9C,0x05,0x07,0x24,0x82,0x93,0x96,0x05,0x0E,0x24,0x82,0x43,0x96,0x05,
	0x82,0x43,0x92,0x05,0x92,0x43,0x84,0x03,0x1F,0x42,0x44,0x04,0x4F,0x93,0x01,0x24,
	0x30,0x41,0xB0,0x12,0x72,0xF7,0xFC,0x3F,0xB0,0x12,0x90,0xF7,0xEF,0x3F,0xB0,0x12,
	0x12,0xFE,0xE5,0x3F,0x82,0x93,0x9C,0x05,0x37,0x20,0x1F,0x42,0xF8,0x04,0x0F,0x93,
	0x20,0x24,0x1F,0x93,0x0A,0x24,0xB2,0x42,0x84,0x03,0x1F,0x42,0x44,0x04,0x4F,0x93,
	0x01,0x24,0x30,0x41,0xB0,0x12,0x72,0xF7,0xFC,0x3F,0x92,0x53,0x92,0x05,0xB2,0x90,
	0x14,0x00,0x92,0x05,0x03,0x2C,0xB0,0x12,0x60,0xFF,0xED,0x3F,0xB0,0x12,0x5A,0xFB,
	0x82,0x93,0xF6,0x04,0x03,0x24,0x82,0x43,0x92,0x05,0xF5,0x3F,0xB0,0x12,0xFE,0xF4,
	0xFA,0x3F,0xB0,0x12,0x5A,0xFB,0x92,0x93,0xF6,0x04,0x0B,0x24,0x82,0x43,0x92,0x05,
	0xB0,0x12,0xFC,0xE9,0xB0,0x12,0x60,0xF2,0xA2,0x42,0x1A,0x03,0xB0,0x12,0x12,0xFE,
	0xD2,0x3F,0xB0,0x12,0xCE,0xF4,0xF2,0x3F,0xB2,0x90,0x03,0x00,0x9C,0x05,0xCB,0x23,
	0xDA,0x3F,0x92,0x43,0xC4,0x04,0xB0,0x12,0x42,0xE2,0x3F,0x40,0x06,0x00,0xB0,0x12,
	0x5E,0xE3,0xB2,0x40,0x00,0x08,0x84,0x03,0x30,0x41,0x0F,0x43,0xB0,0x12,0xE8,0xE2,
	0xB2,0x40,0x00,0x40,0x84,0x03,0x30,0x41,0x3F,0x40,0x03,0x00,0xB0,0x12,0xE8,0xE2,
	0xB2,0x40,0x00,0x80,0x84,0x03,0x30,0x41,0xA2,0x42,0x86,0x03,0x92,0x53,0x98,0x05,
	0x1E,0x42,0x98,0x05,0x1F,0x42,0x9A,0x05,0x0E,0x9F,0x01,0x2C,0x30,0x41,0x3F,0x40,
	0x05,0x00,0xB0,0x12,0x5E,0xE3,0xB2,0x40,0x55,0xAA,0xC2,0x04,0xF7,0x3F,0x0B,0x12,
	0x0A,0x12,0x09,0x12,0x08,0x12,0x08,0x43,0x0A,0x48,0x0A,0x5A,0x1F,0x4A,0x88,0x04,
	0x0B,0x4F,0x3B,0xF0,0x00,0xFF,0x8B,0x10,0x7B,0xF3,0x09,0x4F,0x79,0xF3,0x0D,0x4B,
	0x0E,0x49,0x1F,0x4A,0xA0,0x00,0xB0,0x12,0xDE,0xE4,0x8A,0x4F,0x1E,0x05,0x0D,0x4B,
	0x0E,0x49,0x1F,0x4A,0x9C,0x00,0xB0,0x12,0xDE,0xE4,0x8A,0x4F,0x22,0x05,0x18,0x53,
	0x28,0x93,0xE2,0x2B,0x1F,0x42,0x44,0x04,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,
	0x1F,0x93,0x06,0x20,0x92,0x42,0x22,0x05,0x24,0x05,0x92,0x42,0x1E,0x05,0x20,0x05,
	0x38,0x41,0x39,0x41,0x3A,0x41,0x3B,0x41,0x30,0x41,0x82,0x93,0xF6,0x04,0x1A,0x20,
	0x1F,0x42,0x46,0x04,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,0x1D,0x42,0x1A,0x05,
	0x0F,0x5D,0x1E,0x42,0x16,0x05,0x0E,0x9F,0x02,0x34,0x82,0x43,0x06,0x05,0x1F,0x42,
	0x58,0x04,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,0x0D,0x8F,0x0E,0x9D,0x02,0x34,
	0x82,0x4E,0x1A,0x05,0x30,0x41,0x0B,0x12,0x1B,0x42,0x18,0x05,0x1B,0x82,0x16,0x05,
	0xB0,0x12,0x3C,0xF9,0xB0,0x12,0x68,0xE6,0x0F,0x4B,0xB0,0x12,0xEA,0xE6,0x0F,0x93,
	0x02,0x20,0xB0,0x12,0x9E,0xE6,0x3B,0x41,0x30,0x41,0x0F,0x93,0x04,0x34,0x3F,0xF0,
	0xFF,0x7F,0x3F,0xE3,0x1F,0x53,0x30,0x41,0x0B,0x12,0x0A,0x12,0x0A,0x43,0x0B,0x4A,
	0x0B,0x5B,0x1F,0x4B,0x8E,0x05,0xB0,0x12,0x9C,0xF9,0x0C,0x4F,0x1E,0x4B,0x88,0x04,
	0x0F,0x4E,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,0x7E,0xF3,0x0D,0x4F,0x0F,0x4C,
	0xB0,0x12,0xDE,0xE4,0x8B,0x4F,0x12,0x05,0x1A,0x53,0x2A,0x93,0xE8,0x2B,0x1F,0x42,
	0x44,0x04,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,0x1F,0x93,0x03,0x20,0x92,0x42,
	0x12,0x05,0x14,0x05,0x3A,0x41,0x3B,0x41,0x30,0x41,0x0B,0x12,0x0A,0x12,0x09,0x12,
	0x09,0x4F,0x1A,0x43,0x0B,0x43,0x3D,0x53,0x0D,0x93,0x04,0x24,0x0A,0x5A,0x0B,0x6B,
	0x1D,0x83,0xFC,0x23,0x0F,0x4A,0x3F,0x53,0x1D,0x43,0x0E,0x4F,0x0F,0x49,0xB0,0x12,
	0xDE,0xE4,0x0D,0x4A,0x1E,0x43,0x0F,0x49,0xB0,0x12,0xDE,0xE4,0x39,0x41,0x3A,0x41,
	0x3B,0x41,0x30,0x41,0x92,0x93,0xFE,0x04,0x01,0x24,0x30,0x41,0x92,0x93,0x0E,0x05,
	0xFC,0x23,0xB2,0x90,0x19,0x00,0x7E,0x05,0x02,0x34,0x92,0x53,0x7E,0x05,0xA2,0x92,
	0x7E,0x05,0x0B,0x34,0x1D,0x42,0x7E,0x05,0x1E,0x42,0x16,0x05,0x1F,0x42,0x7A,0x05,
	0xB0,0x12,0xFC,0xF9,0x82,0x4F,0x7A,0x05,0x30,0x41,0x2D,0x42,0x1E,0x42,0x16,0x05,
	0x1F,0x42,0x7A,0x05,0xB0,0x12,0xFC,0xF9,0x82,0x4F,0x7A,0x05,0x82,0x93,0x7C,0x05,
	0x0E,0x38,0x1E,0x42,0x7C,0x05,0x1E,0x52,0x4E,0x04,0x1F,0x42,0x7A,0x05,0x0E,0x9F,
	0x06,0x34,0x1F,0x42,0x7A,0x05,0x1F,0x82,0x4E,0x04,0x82,0x4F,0x7C,0x05,0xB2,0x90,
	0x19,0x00,0x7E,0x05,0x0F,0x24,0x1E,0x42,0x4E,0x04,0x1E,0x82,0x4A,0x04,0x1F,0x42,
	0x7C,0x05,0x0E,0x9F,0xC2,0x37,0x1F,0x42,0x4E,0x04,0x1F,0x82,0x4A,0x04,0x82,0x4F,
	0x7C,0x05,0xBB,0x3F,0x3D,0x40,0x64,0x00,0x3E,0x40,0x63,0x00,0x1F,0x42,0x7C,0x05,
	0xB0,0x12,0xDE,0xE4,0x82,0x4F,0x7C,0x05,0xB2,0x40,0x03,0x00,0x7E,0x05,0x3D,0x40,
	0x64,0x00,0x3E,0x40,0x63,0x00,0x1F,0x42,0x1A,0x05,0xB0,0x12,0xDE,0xE4,0x82,0x4F,
	0x1A,0x05,0xD9,0x3F,0x82,0x43,0xF6,0x04,0x82,0x43,0x06,0x05,0x92,0x42,0x16,0x05,
	0x1A,0x05,0x30,0x41,0xB0,0x12,0x36,0xFA,0x92,0x93,0xF6,0x04,0x07,0x24,0x82,0x43,
	0x7C,0x05,0x82,0x43,0x7A,0x05,0x82,0x43,0x7E,0x05,0x30,0x41,0x1F,0x42,0x4A,0x04,
	0x1F,0x52,0x7C,0x05,0x82,0x9F,0x7A,0x05,0x05,0x34,0x92,0x93,0x7C,0x05,0x02,0x38,
	0xB0,0x12,0xF6,0xFA,0x1F,0x42,0x58,0x04,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,
	0x1F,0x52,0x1A,0x05,0x1E,0x42,0x16,0x05,0x0E,0x9F,0xE7,0x37,0x82,0x9E,0x4A,0x04,
	0xE4,0x37,0xB0,0x12,0xF6,0xFA,0x30,0x41,0xB0,0x12,0xD0,0xF8,0x82,0x93,0x02,0x05,
	0x15,0x20,0xB0,0x12,0xCC,0xF6,0x0F,0x93,0x01,0x20,0x30,0x41,0xB0,0x12,0xBE,0xF6,
	0x0F,0x93,0xFB,0x27,0xB0,0x12,0xAA,0xF9,0x92,0x43,0x02,0x05,0xB0,0x12,0x16,0xE5,
	0xB2,0xD0,0x00,0x01,0x6C,0x03,0x92,0x43,0x88,0x03,0x30,0x41,0x0F,0x43,0xB0,0x12,
	0x74,0xE9,0x1F,0x43,0xB0,0x12,0x74,0xE9,0xB0,0x12,0x68,0xE5,0xB0,0x12,0x9E,0xE5,
	0x1F,0x42,0x26,0x05,0x1F,0x52,0x28,0x05,0x1C,0x38,0x0F,0x11,0x82,0x4F,0x16,0x05,
	0xB0,0x12,0xF2,0xE5,0xB0,0x12,0x78,0xF9,0xB0,0x12,0x06,0xFB,0x82,0x93,0x00,0x05,
	0x0B,0x20,0xB0,0x12,0xD4,0xE8,0x82,0x93,0x9E,0x05,0x03,0x20,0x92,0x43,0x96,0x05,
	0xCC,0x3F,0xB0,0x12,0x9C,0xF6,0xFA,0x3F,0xB0,0x12,0x68,0xE7,0x82,0x43,0x10,0x05,
	0xF2,0x3F,0x1F,0x53,0xE2,0x3F,0x3D,0x40,0x45,0x00,0x0E,0x43,0x3F,0x40,0xF6,0x04,
	0xB0,0x12,0x62,0xE4,0xB2,0x40,0xF0,0xD8,0x18,0x05,0x30,0x41,0x2D,0x42,0x0E,0x43,
	0x3F,0x40,0xA0,0x05,0xB0,0x12,0x62,0xE4,0x30,0x41,0x0B,0x12,0x0A,0x12,0x1A,0x42,
	0x62,0x04,0x7A,0xF3,0x0A,0x93,0x17,0x24,0x3A,0x53,0x0B,0x4A,0x0B,0x5B,0x1E,0x4B,
	0x80,0x04,0x0F,0x4E,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,0x7E,0xF3,0x1C,0x4B,
	0x9A,0x04,0x1C,0x8B,0x90,0x04,0x0D,0x4F,0x0F,0x4C,0xB0,0x12,0xDE,0xE4,0x8B,0x4F,
	0xA4,0x04,0x0A,0x93,0xE9,0x23,0x3A,0x41,0x3B,0x41,0x30,0x41,0x0B,0x12,0x0A,0x12,
	0x1A,0x42,0x62,0x04,0x7A,0xF3,0x0A,0x93,0x1D,0x24,0x3A,0x53,0x0B,0x4A,0x0B,0x5B,
	0x1D,0x4B,0x80,0x04,0x0E,0x4D,0x3E,0xF0,0x00,0xFF,0x8E,0x10,0x7E,0xF3,0x1F,0x42,
	0x66,0x04,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,0x7D,0xF3,0xB0,0x12,0xDE,0xE4,
	0x0E,0x4F,0x0F,0x4B,0x0F,0x5F,0x8F,0x4E,0x9A,0x01,0x9F,0x4B,0x90,0x04,0x98,0x01,
	0x0A,0x93,0xE3,0x23,0x3A,0x41,0x3B,0x41,0x30,0x41,0x21,0x83,0x1F,0x42,0x62,0x04,
	0x7F,0xF3,0x0D,0x41,0x0E,0x4F,0x3F,0x40,0xA4,0x04,0xB0,0x12,0x76,0xE4,0x2F,0x41,
	0x21,0x53,0x30,0x41,0xB2,0x90,0xFF,0x7F,0xE8,0x04,0x32,0x24,0xB0,0x12,0x9C,0xFC,
	0x0E,0x4F,0x1F,0x42,0x64,0x04,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,0x1F,0x52,
	0xA2,0x05,0x0E,0x9F,0x08,0x34,0x82,0x93,0xB0,0x04,0x05,0x24,0x82,0x43,0xBA,0x04,
	0xB2,0x40,0xFF,0x7F,0xE8,0x04,0x1F,0x42,0x64,0x04,0x7F,0xF3,0x0F,0x5F,0x0F,0x9E,
	0x15,0x34,0x1F,0x42,0x64,0x04,0x7F,0xF3,0x0F,0x5F,0x0E,0x8F,0x0F,0x4E,0x82,0x9F,
	0xA2,0x05,0x03,0x34,0x82,0x4F,0xA2,0x05,0x0D,0x3C,0x3D,0x40,0x64,0x00,0x3E,0x40,
	0x63,0x00,0x1F,0x42,0xA2,0x05,0xB0,0x12,0xDE,0xE4,0xF4,0x3F,0x0F,0x43,0xEF,0x3F,
	0x82,0x43,0xA2,0x05,0xB0,0x12,0x2C,0xFD,0x30,0x41,0xB0,0x12,0x9C,0xFC,0x0D,0x4F,
	0x1E,0x42,0xE8,0x04,0x3E,0x90,0xFF,0x7F,0x08,0x24,0xB2,0x90,0xFF,0x7F,0xEC,0x04,
	0x1E,0x24,0x3E,0x90,0xFF,0x7F,0x01,0x24,0x30,0x41,0xB2,0x90,0xFF,0x7F,0xEA,0x04,
	0x03,0x24,0x82,0x4D,0xA4,0x05,0x30,0x41,0x1F,0x42,0x64,0x04,0x7F,0xF3,0x0F,0x93,
	0x0B,0x38,0x0F,0x11,0x0F,0x11,0x0F,0x11,0x1E,0x42,0xA4,0x05,0x0E,0x8F,0x0D,0x9E,
	0xEB,0x37,0x82,0x4D,0xA4,0x05,0xE8,0x3F,0x3F,0x50,0x07,0x00,0xF2,0x3F,0x1F,0x42,
	0x64,0x04,0x7F,0xF3,0x1F,0x52,0xA4,0x05,0x0D,0x9F,0xDB,0x37,0x3E,0x40,0xFF,0x7F,
	0xB2,0x40,0xFF,0x7F,0xE8,0x04,0xD5,0x3F,0x92,0x93,0xB2,0x04,0x01,0x24,0x30,0x41,
	0xB2,0x90,0xFF,0x7F,0xEE,0x04,0x03,0x24,0x92,0x53,0xA6,0x05,0x30,0x41,0x82,0x43,
	0xA6,0x05,0xF5,0x3F,0x1F,0x42,0x6C,0x04,0x3F,0xF0,0x00,0xFF,0x8F,0x10,0x7F,0xF3,
	0x82,0x9F,0xB2,0x04,0x19,0x38,0x82,0x93,0xA6,0x05,0x16,0x24,0xB2,0x90,0x06,0x00,
	0xA6,0x05,0x02,0x38,0x82,0x43,0xA6,0x05,0x92,0x42,0xA6,0x05,0xAE,0x04,0xB2,0x90,
	0x03,0x00,0xA6,0x05,0x11,0x24,0xA2,0x92,0xA6,0x05,0x0A,0x24,0xB2,0x90,0x05,0x00,
	0xA6,0x05,0x03,0x24,0x82,0x43,0xA6,0x05,0x30,0x41,0xA2,0x42,0xAE,0x04,0xFA,0x3F,
	0xB2,0x40,0x03,0x00,0xAE,0x04,0xF6,0x3F,0xB2,0x40,0x06,0x00,0xAE,0x04,0xF2,0x3F,
	0x0B,0x12,0x1B,0x42,0x62,0x04,0x7B,0xF3,0x0B,0x93,0x1B,0x24,0x3B,0x53,0x0F,0x4B,
	0x0F,0x5F,0x1F,0x4F,0x90,0x04,0x1F,0x82,0x60,0x04,0xB0,0x12,0x74,0xE3,0x3F,0x90,
	0xDD,0x05,0x03,0x2C,0x0B,0x93,0xF2,0x23,0x0C,0x3C,0xB2,0x40,0xA5,0x5A,0x86,0x01,
	0x92,0x43,0x18,0x03,0x3F,0x40,0x28,0x00,0xB0,0x12,0x5E,0xE3,0xB0,0x12,0x44,0xF4,
	0xF1,0x3F,0x3B,0x41,0x30,0x41,0x1F,0x42,0xAE,0x04,0x2F,0x93,0x13,0x38,0x82,0x93,
	0x94,0x05,0x0A,0x24,0x92,0x53,0x94,0x05,0xB2,0x90,0x0A,0x00,0x94,0x05,0x03,0x28,
	0x92,0x43,0x94,0x05,0x30,0x41,0x30,0x41,0x1F,0x53,0xB0,0x12,0xFC,0xE2,0x92,0x43,
	0x88,0x03,0xF0,0x3F,0x82,0x43,0x94,0x05,0xB2,0x90,0x05,0x00,0xB0,0x04,0xF3,0x23,
	0x82,0x4F,0xB0,0x04,0xB2,0xD0,0x00,0x02,0x6C,0x03,0x92,0x43,0x88,0x03,0xEB,0x3F,
	0x82,0x93,0xC4,0x04,0x07,0x20,0xB0,0x12,0x60,0xF2,0x3F,0x40,0x0F,0x00,0xB0,0x12,
	0x5E,0xE3,0x30,0x41,0xB0,0x12,0x0C,0xFC,0xB0,0x12,0xB6,0xF0,0x92,0x93,0xC6,0x04,
	0x49,0x24,0xB0,0x12,0x62,0xEA,0xB0,0x12,0x8C,0xEA,0xB0,0x12,0xC0,0xEA,0x0F,0x93,
	0x3E,0x20,0xB0,0x12,0xB6,0xFC,0xB0,0x12,0x6A,0xEB,0xB0,0x12,0xA4,0xEB,0xB0,0x12,
	0x26,0xEC,0xB0,0x12,0xA2,0xEC,0x1F,0x42,0xE8,0x04,0x3F,0x90,0xFF,0x7F,0x04,0x24,
	0xB2,0x90,0xFF,0x7F,0xEA,0x04,0x1E,0x24,0xB0,0x12,0x6C,0xED,0x0F,0x93,0x17,0x24,
	0xB2,0x90,0xFF,0x7F,0xE8,0x04,0x0E,0x24,0xB0,0x12,0x58,0xFE,0x92,0x92,0xB2,0x04,
	0x74,0x04,0x01,0x38,0x30,0x41,0x82,0x43,0xB2,0x04,0xB0,0x12,0x60,0xF2,0xA2,0x42,
	0x1A,0x03,0xF8,0x3F,0xB0,0x12,0x9A,0xFD,0xB0,0x12,0xB6,0xFD,0xED,0x3F,0xB0,0x12,
	0x96,0xED,0xEA,0x3F,0x1F,0x82,0xEE,0x04,0xB0,0x12,0x74,0xE3,0x82,0x9F,0xE6,0x04,
	0x02,0x2C,0x82,0x43,0xA6,0x05,0xB2,0x40,0xFF,0x7F,0xEE,0x04,0xD5,0x3F,0xB0,0x12,
	0x1C,0xEB,0xBF,0x3F,0xB0,0x12,0x60,0xF2,0xA2,0x42,0x1A,0x03,0xA6,0x3F,0xB0,0x12,
	0xFC,0xE9,0xB0,0x12,0xA2,0xFE,0xB0,0x12,0x12,0xFE,0x30,0x41,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,
	0x16,0xE0,0x2C,0xE0,0x42,0xE0,0x58,0xE0,0x6E,0xE0,0x84,0xE0,0x9A,0xE0,0xB0,0xE0,
	0xC6,0xE0,0xDC,0xE0,0xF2,0xE0,0x08,0xE1,0x1E,0xE1,0x34,0xE1,0x4A,0xE1,0x60,0xE1,
	0x76,0xE1,0x8C,0xE1,0xA2,0xE1,0xB8,0xE1,0xCE,0xE1,0xE4,0xE1,0xFA,0xE1,0x44,0xF4,
	0x44,0xF4,0x10,0xE2,0x44,0xF4,0x44,0xF4,0x44,0xF4,0x44,0xF4,0x44,0xF4,


};
#else
//no Foolproof PATCH
const unsigned char GH61X_PATCH_ADDR[3086] = {
    0x03, 0x09, 0x01, 0x00, 0x00, 0x36, 0x31, 0x30, 0xD6, 0x1F, 0x1E, 0x75, 0x0C, 0x70, 0xDC, 0xEA, 0xDC, 0x24, 0x0E, 0x43, 0x3D, 0x40, 0x00, 0x04, 0x0F, 0x4E,
    0x0F, 0x5F, 0x0F, 0x5D, 0xBF, 0x40, 0x44, 0xF4, 0x00, 0x00, 0x1E, 0x53, 0x3E, 0x90, 0x19, 0x00, 0xF6, 0x2B, 0xB2, 0x40, 0xC0, 0xF7, 0x00, 0x04, 0xB2, 0x40,
    0xFC, 0xF7, 0x06, 0x04, 0xB2, 0x40, 0xA8, 0xF8, 0x16, 0x04, 0xB2, 0x40, 0xC0, 0xF8, 0x1C, 0x04, 0xB2, 0x40, 0xCE, 0xF8, 0x1E, 0x04, 0xB2, 0x40, 0xEA, 0xF8,
    0x24, 0x04, 0x30, 0x41, 0x3F, 0x40, 0xFE, 0x05, 0x01, 0x4F, 0xB0, 0x12, 0x04, 0xF4, 0x32, 0xC2, 0xB2, 0x43, 0x84, 0x03, 0xB2, 0x43, 0x86, 0x03, 0x32, 0xD2,
    0x30, 0x40, 0x60, 0xF4, 0x30, 0x41, 0x31, 0x40, 0xFE, 0x05, 0x82, 0x43, 0xAE, 0x05, 0xB0, 0x12, 0x42, 0xE2, 0x3F, 0x40, 0x06, 0x00, 0xB0, 0x12, 0x5E, 0xE3,
    0xB0, 0x12, 0xBA, 0xE2, 0xB0, 0x12, 0x4E, 0xE3, 0xB0, 0x12, 0xAA, 0xF6, 0x92, 0x43, 0xAE, 0x05, 0xB0, 0x12, 0x10, 0xE3, 0x0F, 0x93, 0xFC, 0x27, 0x32, 0xD0,
    0x10, 0x00, 0xF9, 0x3F, 0x30, 0x40, 0x34, 0xF3, 0x3F, 0x40, 0x01, 0x09, 0xB0, 0x12, 0xA0, 0xE2, 0x30, 0x41, 0x82, 0x93, 0x9C, 0x05, 0x0D, 0x24, 0xA2, 0x93,
    0x9C, 0x05, 0x0A, 0x24, 0x92, 0x93, 0x9C, 0x05, 0x04, 0x24, 0xB2, 0x90, 0x03, 0x00, 0x9C, 0x05, 0x05, 0x20, 0xB0, 0x12, 0x96, 0xF4, 0x02, 0x3C, 0xB0, 0x12,
    0x92, 0xE2, 0xB0, 0x12, 0xAE, 0xFC, 0x30, 0x41, 0xB0, 0x12, 0xD6, 0xE9, 0xB0, 0x12, 0x7E, 0xFC, 0xB2, 0x90, 0x20, 0x03, 0x86, 0x01, 0x02, 0x20, 0xB0, 0x12,
    0x66, 0xFC, 0xB2, 0x40, 0x72, 0xF5, 0x34, 0x04, 0x30, 0x41, 0x0F, 0x43, 0xB0, 0x12, 0xFC, 0xE2, 0x92, 0x43, 0x88, 0x03, 0x92, 0x43, 0xF8, 0x04, 0x82, 0x93,
    0x9C, 0x05, 0x01, 0x24, 0x30, 0x41, 0xB0, 0x12, 0xD6, 0xE9, 0xB0, 0x12, 0x7E, 0xFC, 0xB0, 0x12, 0xAE, 0xFC, 0xB0, 0x12, 0x96, 0xF4, 0x1F, 0x42, 0x78, 0x04,
    0xB0, 0x12, 0x26, 0xE2, 0xF2, 0x3F, 0x1F, 0x43, 0xB0, 0x12, 0xFC, 0xE2, 0x92, 0x43, 0x88, 0x03, 0x82, 0x43, 0xF8, 0x04, 0x82, 0x93, 0x9C, 0x05, 0x01, 0x24,
    0x30, 0x41, 0xB0, 0x12, 0x92, 0xE2, 0xFC, 0x3F, 0x0B, 0x12, 0x0B, 0x43, 0x82, 0x43, 0x98, 0x05, 0xB2, 0x40, 0xAA, 0x55, 0xC2, 0x04, 0x3F, 0x40, 0x42, 0x00,
    0xDF, 0xC3, 0x00, 0x00, 0xDF, 0xD3, 0x00, 0x00, 0xDF, 0xC3, 0x00, 0x00, 0xB2, 0x90, 0xAA, 0x55, 0xC2, 0x04, 0x0B, 0x20, 0x1F, 0x43, 0xB0, 0x12, 0x5E, 0xE3,
    0x1B, 0x53, 0x3B, 0x90, 0x64, 0x00, 0xE7, 0x2F, 0xB2, 0x90, 0xAA, 0x55, 0xC2, 0x04, 0xF5, 0x27, 0x3B, 0x41, 0x30, 0x41, 0x0B, 0x12, 0x0A, 0x12, 0x09, 0x12,
    0x08, 0x12, 0x07, 0x12, 0x06, 0x12, 0x05, 0x12, 0x04, 0x12, 0x0C, 0x4F, 0x35, 0x40, 0x00, 0x02, 0x82, 0x93, 0x9E, 0x05, 0x33, 0x24, 0x37, 0x40, 0xA0, 0x0F,
    0x1E, 0x42, 0x42, 0x00, 0x3E, 0xF0, 0x0F, 0xC0, 0x1F, 0x43, 0x0D, 0x4C, 0x2D, 0x52, 0x0D, 0x93, 0x03, 0x24, 0x0F, 0x5F, 0x1D, 0x83, 0xFD, 0x23, 0x0E, 0xDF,
    0x82, 0x4E, 0x42, 0x00, 0x0A, 0x4C, 0x0A, 0x5A, 0x18, 0x4A, 0x80, 0x05, 0x39, 0x40, 0x09, 0x00, 0x0B, 0x48, 0x0B, 0x55, 0x12, 0xC3, 0x0B, 0x10, 0x8A, 0x4B,
    0x6C, 0x00, 0xB0, 0x12, 0x32, 0xF5, 0x1F, 0x4A, 0x96, 0x00, 0x0F, 0x97, 0x0E, 0x34, 0x05, 0x4B, 0x0F, 0x87, 0xB0, 0x12, 0x74, 0xE3, 0x39, 0x90, 0x09, 0x00,
    0x02, 0x24, 0x0F, 0x96, 0x02, 0x2C, 0x06, 0x4F, 0x04, 0x4B, 0x39, 0x53, 0xE7, 0x23, 0x05, 0x3C, 0x08, 0x4B, 0xF1, 0x3F, 0x37, 0x40, 0x80, 0x0C, 0xCC, 0x3F,
    0x8A, 0x44, 0x6C, 0x00, 0x34, 0x41, 0x35, 0x41, 0x36, 0x41, 0x37, 0x41, 0x38, 0x41, 0x39, 0x41, 0x3A, 0x41, 0x3B, 0x41, 0x30, 0x41, 0xE2, 0xD2, 0x82, 0x03,
    0xF2, 0xD0, 0x80, 0xFF, 0x43, 0x00, 0x0F, 0x43, 0xB0, 0x12, 0xB2, 0xF1, 0xF2, 0xF0, 0x7F, 0x00, 0x43, 0x00, 0x30, 0x41, 0x0E, 0x4F, 0x0E, 0x5E, 0x1F, 0x4E,
    0x72, 0x00, 0x1F, 0x5E, 0x76, 0x00, 0x12, 0xC3, 0x0F, 0x10, 0x8E, 0x4F, 0x72, 0x00, 0x8E, 0x4F, 0x76, 0x00, 0x30, 0x41, 0x0F, 0x43, 0xB0, 0x12, 0x28, 0xF6,
    0x1F, 0x43, 0xB0, 0x12, 0x28, 0xF6, 0x30, 0x41, 0x0E, 0x4F, 0x0E, 0x5E, 0xBE, 0x90, 0x9D, 0x18, 0x9C, 0x00, 0x04, 0x2C, 0xBE, 0x90, 0x9D, 0x18, 0xA0, 0x00,
    0x0C, 0x28, 0x1F, 0x4E, 0x72, 0x00, 0x1F, 0x53, 0x3F, 0x90, 0xFF, 0x01, 0x05, 0x2C, 0x9E, 0x53, 0x72, 0x00, 0x9E, 0x53, 0x76, 0x00, 0x30, 0x41, 0x30, 0x41,
    0xBE, 0x90, 0xFC, 0x08, 0x9C, 0x00, 0x04, 0x28, 0xBE, 0x90, 0xFC, 0x08, 0xA0, 0x00, 0xF7, 0x2F, 0xAE, 0x93, 0x72, 0x00, 0xF4, 0x2B, 0xBE, 0x53, 0x72, 0x00,
    0xBE, 0x53, 0x76, 0x00, 0xEF, 0x3F, 0x0F, 0x43, 0xB0, 0x12, 0x50, 0xF6, 0x1F, 0x43, 0xB0, 0x12, 0x50, 0xF6, 0x30, 0x41, 0xF2, 0xB0, 0x40, 0x00, 0x1C, 0x03,
    0x03, 0x24, 0xB0, 0x12, 0xDA, 0xF6, 0x30, 0x41, 0xB2, 0x42, 0x18, 0x03, 0x30, 0x41, 0x82, 0x93, 0x80, 0x05, 0x02, 0x24, 0x1F, 0x43, 0x30, 0x41, 0x0F, 0x43,
    0x30, 0x41, 0xB2, 0x93, 0x8E, 0x05, 0x02, 0x24, 0x1F, 0x43, 0x30, 0x41, 0x0F, 0x43, 0x30, 0x41, 0xB0, 0x12, 0xCA, 0xF4, 0x82, 0x43, 0x92, 0x05, 0x82, 0x43,
    0x94, 0x05, 0x82, 0x43, 0x96, 0x05, 0x5F, 0x42, 0x40, 0x00, 0x12, 0xC3, 0x4F, 0x10, 0x4F, 0x11, 0x4F, 0x11, 0x4F, 0x11, 0x7F, 0xF3, 0x1F, 0x53, 0x82, 0x4F,
    0x9A, 0x05, 0x1F, 0x42, 0x40, 0x04, 0x3F, 0xF0, 0x00, 0x0F, 0x8F, 0x10, 0x7F, 0xF3, 0x82, 0x4F, 0x9C, 0x05, 0xB0, 0x12, 0xBE, 0xF6, 0x82, 0x4F, 0x9E, 0x05,
    0xB0, 0x12, 0xBA, 0xE2, 0x82, 0x43, 0x88, 0x03, 0xB2, 0x90, 0x20, 0x03, 0x86, 0x01, 0x18, 0x24, 0xB0, 0x12, 0x10, 0xF6, 0x1F, 0x42, 0x78, 0x04, 0xB0, 0x12,
    0x26, 0xE2, 0xE2, 0xC2, 0x82, 0x03, 0xD2, 0xD3, 0x42, 0x00, 0xB0, 0x12, 0xAC, 0xE2, 0x92, 0x93, 0x9C, 0x05, 0x04, 0x24, 0xB2, 0x90, 0x03, 0x00, 0x9C, 0x05,
    0x0F, 0x20, 0x1F, 0x42, 0x78, 0x04, 0xB0, 0x12, 0x26, 0xE2, 0x0A, 0x3C, 0xB0, 0x12, 0xA0, 0xF4, 0xB0, 0x12, 0xB0, 0xF2, 0x82, 0x93, 0x9E, 0x05, 0xE7, 0x27,
    0xB0, 0x12, 0x42, 0xF6, 0xE4, 0x3F, 0xB2, 0x40, 0x20, 0x03, 0x86, 0x01, 0xA2, 0x42, 0x18, 0x03, 0x30, 0x41, 0xB0, 0x12, 0x10, 0xE3, 0x0F, 0x93, 0x01, 0x20,
    0x30, 0x41, 0xB0, 0x12, 0x24, 0xE3, 0x0F, 0x93, 0xFB, 0x27, 0x82, 0x43, 0x88, 0x03, 0xF2, 0xD0, 0x20, 0x00, 0x18, 0x03, 0xF5, 0x3F, 0xB0, 0x12, 0x78, 0xFB,
    0x1F, 0x42, 0xF8, 0x04, 0x0F, 0x93, 0x03, 0x20, 0x92, 0x93, 0xF6, 0x04, 0x09, 0x24, 0x1F, 0x93, 0x01, 0x24, 0x30, 0x41, 0x82, 0x93, 0xF6, 0x04, 0xFC, 0x23,
    0xB0, 0x12, 0x16, 0xF5, 0xF9, 0x3F, 0xB0, 0x12, 0xE6, 0xF4, 0x30, 0x41, 0x82, 0x93, 0x9E, 0x05, 0x18, 0x20, 0xB2, 0x90, 0x03, 0x00, 0x9C, 0x05, 0x07, 0x24,
    0x82, 0x93, 0x96, 0x05, 0x0E, 0x24, 0x82, 0x43, 0x96, 0x05, 0x82, 0x43, 0x92, 0x05, 0x92, 0x43, 0x84, 0x03, 0x1F, 0x42, 0x44, 0x04, 0x4F, 0x93, 0x01, 0x24,
    0x30, 0x41, 0xB0, 0x12, 0x78, 0xF7, 0xFC, 0x3F, 0xB0, 0x12, 0x96, 0xF7, 0xEF, 0x3F, 0xB0, 0x12, 0x38, 0xFD, 0xE5, 0x3F, 0x82, 0x93, 0x9C, 0x05, 0x37, 0x20,
    0x1F, 0x42, 0xF8, 0x04, 0x0F, 0x93, 0x20, 0x24, 0x1F, 0x93, 0x0A, 0x24, 0xB2, 0x42, 0x84, 0x03, 0x1F, 0x42, 0x44, 0x04, 0x4F, 0x93, 0x01, 0x24, 0x30, 0x41,
    0xB0, 0x12, 0x78, 0xF7, 0xFC, 0x3F, 0x92, 0x53, 0x92, 0x05, 0xB2, 0x90, 0x14, 0x00, 0x92, 0x05, 0x03, 0x2C, 0xB0, 0x12, 0x58, 0xFF, 0xED, 0x3F, 0xB0, 0x12,
    0x78, 0xFB, 0x82, 0x93, 0xF6, 0x04, 0x03, 0x24, 0x82, 0x43, 0x92, 0x05, 0xF5, 0x3F, 0xB0, 0x12, 0x16, 0xF5, 0xFA, 0x3F, 0xB0, 0x12, 0x78, 0xFB, 0x92, 0x93,
    0xF6, 0x04, 0x0B, 0x24, 0x82, 0x43, 0x92, 0x05, 0xB0, 0x12, 0xFC, 0xE9, 0xB0, 0x12, 0x60, 0xF2, 0xA2, 0x42, 0x1A, 0x03, 0xB0, 0x12, 0x38, 0xFD, 0xD2, 0x3F,
    0xB0, 0x12, 0xE6, 0xF4, 0xF2, 0x3F, 0xA2, 0x93, 0x9C, 0x05, 0x16, 0x24, 0x92, 0x93, 0x9C, 0x05, 0x05, 0x24, 0xB2, 0x90, 0x03, 0x00, 0x9C, 0x05, 0xC5, 0x23,
    0xD4, 0x3F, 0x92, 0x53, 0x92, 0x05, 0xB2, 0x90, 0x14, 0x00, 0x92, 0x05, 0x03, 0x2C, 0xB0, 0x12, 0x58, 0xFF, 0xE6, 0x3F, 0xB0, 0x12, 0x96, 0xF7, 0x82, 0x43,
    0x92, 0x05, 0xF8, 0x3F, 0xB0, 0x12, 0x96, 0xF7, 0xB3, 0x3F, 0x92, 0x43, 0xC4, 0x04, 0xB0, 0x12, 0x42, 0xE2, 0x3F, 0x40, 0x06, 0x00, 0xB0, 0x12, 0x5E, 0xE3,
    0xB2, 0x40, 0x00, 0x08, 0x84, 0x03, 0x30, 0x41, 0x0F, 0x43, 0xB0, 0x12, 0xE8, 0xE2, 0xB2, 0x40, 0x00, 0x40, 0x84, 0x03, 0x30, 0x41, 0xB0, 0x12, 0x42, 0xE2,
    0x3F, 0x40, 0x06, 0x00, 0xB0, 0x12, 0x5E, 0xE3, 0x3F, 0x40, 0x03, 0x00, 0xB0, 0x12, 0xE8, 0xE2, 0xB2, 0x40, 0x00, 0x80, 0x84, 0x03, 0x30, 0x41, 0xA2, 0x42,
    0x86, 0x03, 0x92, 0x53, 0x98, 0x05, 0x1E, 0x42, 0x98, 0x05, 0x1F, 0x42, 0x9A, 0x05, 0x0E, 0x9F, 0x01, 0x2C, 0x30, 0x41, 0x3F, 0x40, 0x05, 0x00, 0xB0, 0x12,
    0x5E, 0xE3, 0xB2, 0x40, 0x55, 0xAA, 0xC2, 0x04, 0xF7, 0x3F, 0x0B, 0x12, 0x0A, 0x12, 0x09, 0x12, 0x09, 0x43, 0x0B, 0x49, 0x0B, 0x5B, 0x1A, 0x4B, 0x88, 0x04,
    0x7A, 0xF3, 0x3D, 0x40, 0x20, 0x00, 0x0E, 0x4A, 0x1F, 0x4B, 0xA0, 0x00, 0xB0, 0x12, 0xDE, 0xE4, 0x8B, 0x4F, 0x1E, 0x05, 0x3D, 0x40, 0x20, 0x00, 0x0E, 0x4A,
    0x1F, 0x4B, 0x9C, 0x00, 0xB0, 0x12, 0xDE, 0xE4, 0x8B, 0x4F, 0x22, 0x05, 0x19, 0x53, 0x29, 0x93, 0xE6, 0x2B, 0xB2, 0xB0, 0x00, 0x40, 0x44, 0x04, 0x06, 0x24,
    0x92, 0x42, 0x22, 0x05, 0x24, 0x05, 0x92, 0x42, 0x1E, 0x05, 0x20, 0x05, 0x39, 0x41, 0x3A, 0x41, 0x3B, 0x41, 0x30, 0x41, 0x0D, 0x4F, 0x0D, 0x5D, 0x0C, 0x4D,
    0x3C, 0x50, 0xFA, 0x04, 0x8C, 0x93, 0x00, 0x00, 0x0B, 0x20, 0x1E, 0x4D, 0x46, 0x04, 0x7E, 0xF3, 0x1F, 0x4D, 0x26, 0x05, 0x0E, 0x9F, 0x03, 0x34, 0x9C, 0x43,
    0x00, 0x00, 0x30, 0x41, 0x30, 0x41, 0x1F, 0x4D, 0x46, 0x04, 0x3F, 0xF0, 0x00, 0xFF, 0x8F, 0x10, 0x7F, 0xF3, 0x8D, 0x9F, 0x26, 0x05, 0xF6, 0x37, 0x8C, 0x43,
    0x00, 0x00, 0xF3, 0x3F, 0x0F, 0x43, 0xB0, 0x12, 0x68, 0xF9, 0x1F, 0x43, 0xB0, 0x12, 0x68, 0xF9, 0x0E, 0x43, 0x1F, 0x42, 0xFA, 0x04, 0x0F, 0x93, 0x04, 0x24,
    0x82, 0x93, 0xFC, 0x04, 0x01, 0x24, 0x1E, 0x43, 0x82, 0x4E, 0xFE, 0x04, 0x0E, 0x43, 0x0F, 0x93, 0x03, 0x20, 0x82, 0x93, 0xFC, 0x04, 0x01, 0x24, 0x1E, 0x43,
    0x82, 0x4E, 0x00, 0x05, 0x30, 0x41, 0x0F, 0x93, 0x04, 0x34, 0x3F, 0xF0, 0xFF, 0x7F, 0x3F, 0xE3, 0x1F, 0x53, 0x30, 0x41, 0x0B, 0x12, 0x0A, 0x12, 0x0A, 0x43,
    0x0B, 0x4A, 0x0B, 0x5B, 0x1F, 0x4B, 0x8E, 0x05, 0xB0, 0x12, 0xDC, 0xF9, 0x0C, 0x4F, 0x1F, 0x4B, 0x88, 0x04, 0x7F, 0xF3, 0x3D, 0x40, 0x20, 0x00, 0x0E, 0x4F,
    0x0F, 0x4C, 0xB0, 0x12, 0xDE, 0xE4, 0x8B, 0x4F, 0x12, 0x05, 0x1A, 0x53, 0x2A, 0x93, 0xEB, 0x2B, 0xB2, 0xB0, 0x00, 0x40, 0x44, 0x04, 0x03, 0x24, 0x92, 0x42,
    0x12, 0x05, 0x14, 0x05, 0x3A, 0x41, 0x3B, 0x41, 0x30, 0x41, 0x1F, 0x42, 0x54, 0x04, 0x3F, 0xF0, 0x00, 0xFF, 0x8F, 0x10, 0x7F, 0xF3, 0x1E, 0x42, 0xFE, 0x04,
    0x1E, 0x92, 0x00, 0x05, 0x13, 0x24, 0x82, 0x43, 0x06, 0x05, 0x92, 0x53, 0x04, 0x05, 0x1F, 0x42, 0x54, 0x04, 0x7F, 0xF3, 0x82, 0x9F, 0x04, 0x05, 0x08, 0x38,
    0x82, 0x43, 0x04, 0x05, 0x92, 0x42, 0xF6, 0x04, 0xFA, 0x04, 0x92, 0x42, 0xF6, 0x04, 0xFC, 0x04, 0x30, 0x41, 0x0E, 0x93, 0x03, 0x20, 0x1F, 0x42, 0xB6, 0x01,
    0x7F, 0xF3, 0x82, 0x43, 0x04, 0x05, 0x92, 0x53, 0x06, 0x05, 0x82, 0x9F, 0x06, 0x05, 0xF3, 0x3B, 0x82, 0x4E, 0xF6, 0x04, 0x82, 0x43, 0x06, 0x05, 0x30, 0x41,
    0x0B, 0x12, 0x21, 0x82, 0x1B, 0x42, 0x10, 0x05, 0x82, 0x93, 0x2A, 0x05, 0x1F, 0x24, 0x0F, 0x41, 0xB0, 0x12, 0xCC, 0xE7, 0x82, 0x93, 0x1C, 0x05, 0x0A, 0x20,
    0x92, 0x43, 0x1C, 0x05, 0xA2, 0x41, 0x88, 0x01, 0x92, 0x41, 0x02, 0x00, 0x8A, 0x01, 0xB2, 0x40, 0xA5, 0x5A, 0x8C, 0x01, 0x2E, 0x41, 0x1F, 0x42, 0x88, 0x01,
    0x0E, 0x9F, 0x02, 0x34, 0x82, 0x4E, 0x88, 0x01, 0x1E, 0x41, 0x02, 0x00, 0x1F, 0x42, 0x8A, 0x01, 0x0E, 0x9F, 0x02, 0x34, 0x82, 0x4E, 0x8A, 0x01, 0x82, 0x4B,
    0x10, 0x05, 0x21, 0x52, 0x3B, 0x41, 0x30, 0x41, 0x0B, 0x12, 0x0A, 0x12, 0x09, 0x12, 0x0F, 0x5F, 0x8F, 0x93, 0xFA, 0x04, 0x03, 0x20, 0x8F, 0x93, 0x26, 0x05,
    0x03, 0x38, 0x8F, 0x43, 0xAA, 0x05, 0x29, 0x3C, 0x0E, 0x4F, 0x3E, 0x50, 0xAA, 0x05, 0xBE, 0x90, 0x03, 0x00, 0x00, 0x00, 0x03, 0x34, 0x9E, 0x53, 0x00, 0x00,
    0x1F, 0x3C, 0x82, 0x93, 0x38, 0x05, 0x1C, 0x24, 0x09, 0x4F, 0x39, 0x50, 0x12, 0x05, 0x0B, 0x4F, 0x0B, 0x5B, 0x0B, 0x5B, 0x0F, 0x5F, 0x0B, 0x5F, 0x0B, 0x5F,
    0x0B, 0x5F, 0x0F, 0x4B, 0x3F, 0x50, 0x60, 0x05, 0x3E, 0x40, 0x03, 0x00, 0xB0, 0x12, 0x80, 0xE3, 0x0A, 0x4F, 0x3B, 0x50, 0x38, 0x05, 0x3E, 0x40, 0x03, 0x00,
    0x0F, 0x4B, 0xB0, 0x12, 0x80, 0xE3, 0x0A, 0x8F, 0x89, 0x4A, 0x00, 0x00, 0x39, 0x41, 0x3A, 0x41, 0x3B, 0x41, 0x30, 0x41, 0x21, 0x82, 0xB0, 0x12, 0x68, 0xE7,
    0xB0, 0x12, 0xAA, 0xE7, 0x0F, 0x93, 0x08, 0x24, 0x0F, 0x41, 0xB0, 0x12, 0xCC, 0xE7, 0xB0, 0x12, 0x8C, 0xFA, 0x0F, 0x41, 0xB0, 0x12, 0xB6, 0xE8, 0x21, 0x52,
    0x30, 0x41, 0x0B, 0x12, 0x0A, 0x12, 0xB0, 0x12, 0x10, 0xF9, 0x82, 0x93, 0x02, 0x05, 0x1D, 0x20, 0xB0, 0x12, 0xCC, 0xF6, 0x0F, 0x93, 0x0E, 0x20, 0x82, 0x93,
    0x44, 0x04, 0x66, 0x38, 0xB0, 0x12, 0x88, 0xE9, 0x92, 0x93, 0x1C, 0x05, 0x61, 0x20, 0xB2, 0xD0, 0x00, 0x01, 0x6C, 0x03, 0x92, 0x43, 0x88, 0x03, 0x5B, 0x3C,
    0xB0, 0x12, 0xBE, 0xF6, 0x0F, 0x93, 0xEE, 0x27, 0xB0, 0x12, 0xEA, 0xF9, 0x92, 0x43, 0x02, 0x05, 0xB0, 0x12, 0x16, 0xE5, 0xEF, 0x3F, 0x0F, 0x43, 0xB0, 0x12,
    0x74, 0xE9, 0x1F, 0x43, 0xB0, 0x12, 0x74, 0xE9, 0xB0, 0x12, 0xA6, 0xF9, 0xB0, 0x12, 0x2E, 0xFA, 0x3D, 0x40, 0xB6, 0x01, 0x2F, 0x4D, 0x3F, 0xF0, 0x00, 0xFF,
    0x8F, 0x10, 0x7F, 0xF3, 0x1E, 0x42, 0x26, 0x05, 0x0A, 0x4F, 0x0C, 0x4E, 0xB0, 0x12, 0x38, 0xF3, 0x0B, 0x4E, 0x2F, 0x4D, 0x3F, 0xF0, 0x00, 0xFF, 0x8F, 0x10,
    0x7F, 0xF3, 0x3E, 0x40, 0x0A, 0x00, 0x0E, 0x8F, 0x1F, 0x42, 0x28, 0x05, 0x0A, 0x4E, 0x0C, 0x4F, 0xB0, 0x12, 0x38, 0xF3, 0x0B, 0x5E, 0x82, 0x4B, 0x16, 0x05,
    0x3D, 0x40, 0x0A, 0x00, 0x1E, 0x43, 0x0F, 0x4B, 0xB0, 0x12, 0xDE, 0xE4, 0x82, 0x4F, 0x16, 0x05, 0xB0, 0x12, 0xF2, 0xE5, 0xB0, 0x12, 0x68, 0xE6, 0x82, 0x93,
    0x00, 0x05, 0x11, 0x20, 0xB0, 0x12, 0x56, 0xFB, 0x0F, 0x43, 0xB0, 0x12, 0xE2, 0xFA, 0x1F, 0x43, 0xB0, 0x12, 0xE2, 0xFA, 0x82, 0x93, 0x9E, 0x05, 0x03, 0x20,
    0x92, 0x43, 0x96, 0x05, 0x0A, 0x3C, 0xB0, 0x12, 0x9C, 0xF6, 0xFA, 0x3F, 0xB0, 0x12, 0x68, 0xE7, 0x82, 0x43, 0x10, 0x05, 0xB0, 0x12, 0x8C, 0xFA, 0xEA, 0x3F,
    0x3A, 0x41, 0x3B, 0x41, 0x30, 0x41, 0x3D, 0x40, 0x45, 0x00, 0x0E, 0x43, 0x3F, 0x40, 0xF6, 0x04, 0xB0, 0x12, 0x62, 0xE4, 0x82, 0x43, 0xAA, 0x05, 0x82, 0x43,
    0xAC, 0x05, 0x30, 0x41, 0x3D, 0x40, 0x05, 0x00, 0x0E, 0x43, 0x3F, 0x40, 0xA0, 0x05, 0xB0, 0x12, 0x62, 0xE4, 0x30, 0x41, 0x1F, 0x42, 0x80, 0x04, 0x7F, 0xF3,
    0x1C, 0x42, 0x9A, 0x04, 0x1C, 0x82, 0x90, 0x04, 0x3D, 0x40, 0x20, 0x00, 0x0E, 0x4F, 0x0F, 0x4C, 0xB0, 0x12, 0xDE, 0xE4, 0x82, 0x4F, 0xA4, 0x04, 0x30, 0x41,
    0x1F, 0x42, 0x80, 0x04, 0x7F, 0xF3, 0x1C, 0x42, 0x66, 0x04, 0x3C, 0xF0, 0x00, 0xFF, 0x8C, 0x10, 0x7C, 0xF3, 0x0D, 0x4F, 0x3E, 0x40, 0x20, 0x00, 0x0F, 0x4C,
    0xB0, 0x12, 0xDE, 0xE4, 0x82, 0x4F, 0x9A, 0x01, 0x92, 0x42, 0x90, 0x04, 0x98, 0x01, 0x30, 0x41, 0x92, 0x93, 0xB2, 0x04, 0x01, 0x24, 0x30, 0x41, 0xB2, 0x90,
    0xFF, 0x7F, 0xEE, 0x04, 0x03, 0x24, 0x92, 0x53, 0xA6, 0x05, 0x30, 0x41, 0x82, 0x43, 0xA6, 0x05, 0xF5, 0x3F, 0x1F, 0x42, 0x6C, 0x04, 0x3F, 0xF0, 0x00, 0xFF,
    0x8F, 0x10, 0x7F, 0xF3, 0x82, 0x9F, 0xB2, 0x04, 0x18, 0x38, 0x82, 0x93, 0xA6, 0x05, 0x15, 0x24, 0xB2, 0x90, 0x06, 0x00, 0xA6, 0x05, 0x02, 0x38, 0x82, 0x43,
    0xA6, 0x05, 0x92, 0x42, 0xA6, 0x05, 0xAE, 0x04, 0xB2, 0x90, 0x03, 0x00, 0xA6, 0x05, 0x06, 0x38, 0x1F, 0x42, 0xA6, 0x05, 0x3F, 0x50, 0x03, 0x00, 0x82, 0x4F,
    0xAE, 0x04, 0x82, 0x43, 0xA6, 0x05, 0x30, 0x41, 0x1F, 0x42, 0x90, 0x04, 0x3F, 0x50, 0x60, 0xF0, 0xB0, 0x12, 0x74, 0xE3, 0x3F, 0x90, 0xDD, 0x05, 0x01, 0x2C,
    0x30, 0x41, 0xB2, 0x40, 0xA5, 0x5A, 0x86, 0x01, 0x92, 0x43, 0x18, 0x03, 0x3F, 0x40, 0x28, 0x00, 0xB0, 0x12, 0x5E, 0xE3, 0xB0, 0x12, 0x44, 0xF4, 0xF3, 0x3F,
    0x1E, 0x42, 0xAE, 0x04, 0x0E, 0x93, 0x40, 0x24, 0x1F, 0x42, 0x40, 0x04, 0x7F, 0xF3, 0x0D, 0x4E, 0x3D, 0x53, 0x0D, 0x93, 0x04, 0x24, 0x12, 0xC3, 0x0F, 0x10,
    0x1D, 0x83, 0xFC, 0x23, 0x1F, 0xF3, 0x03, 0x20, 0x3E, 0x90, 0x09, 0x00, 0x2F, 0x38, 0x82, 0x93, 0x94, 0x05, 0x09, 0x20, 0x3E, 0x90, 0x06, 0x00, 0x26, 0x38,
    0x3F, 0x40, 0x07, 0x00, 0xB0, 0x12, 0xFC, 0xE2, 0x92, 0x43, 0x88, 0x03, 0x92, 0x53, 0x94, 0x05, 0x1E, 0x42, 0x94, 0x05, 0x1F, 0x42, 0x94, 0x01, 0x0E, 0x9F,
    0x04, 0x24, 0x92, 0x42, 0xAE, 0x04, 0x92, 0x01, 0x30, 0x41, 0xB2, 0xB0, 0x00, 0x01, 0x44, 0x04, 0x09, 0x24, 0x3F, 0x40, 0x07, 0x00, 0xB0, 0x12, 0xFC, 0xE2,
    0x92, 0x43, 0x88, 0x03, 0xB2, 0x40, 0x0B, 0x00, 0xAE, 0x04, 0xB2, 0xB0, 0x00, 0x04, 0x44, 0x04, 0xEB, 0x27, 0x82, 0x43, 0x94, 0x05, 0xE8, 0x3F, 0x1E, 0x53,
    0x0F, 0x4E, 0xD9, 0x3F, 0x30, 0x41, 0x82, 0x43, 0x94, 0x05, 0xB2, 0xB0, 0x00, 0x02, 0x44, 0x04, 0xF9, 0x27, 0xB2, 0x90, 0x05, 0x00, 0xB0, 0x04, 0xF5, 0x23,
    0x82, 0x43, 0xB0, 0x04, 0xB2, 0xD0, 0x00, 0x02, 0x6C, 0x03, 0x92, 0x43, 0x88, 0x03, 0xED, 0x3F, 0x0B, 0x12, 0x1F, 0x42, 0xB4, 0x04, 0x3F, 0x90, 0xFF, 0x00,
    0x03, 0x34, 0x1F, 0x53, 0x82, 0x4F, 0xB4, 0x04, 0x82, 0x43, 0xB2, 0x04, 0x1F, 0x42, 0xE8, 0x04, 0x1F, 0x82, 0xEC, 0x04, 0xB0, 0x12, 0x74, 0xE3, 0x0B, 0x4F,
    0x1F, 0x42, 0xB4, 0x01, 0x7F, 0xF3, 0x82, 0x9F, 0xB4, 0x04, 0x14, 0x34, 0xB0, 0x12, 0x66, 0xF0, 0x0F, 0x93, 0x16, 0x20, 0x1F, 0x42, 0xE8, 0x04, 0x1F, 0x82,
    0xEA, 0x04, 0xB0, 0x12, 0x74, 0xE3, 0x2D, 0x43, 0x0E, 0x4B, 0xB0, 0x12, 0xE6, 0xEF, 0x0F, 0x93, 0x0A, 0x20, 0x92, 0x42, 0xE8, 0x04, 0xEA, 0x04, 0x06, 0x3C,
    0x3E, 0x40, 0x03, 0x00, 0x0F, 0x4B, 0xB0, 0x12, 0x7E, 0xF0, 0xE6, 0x3F, 0x3B, 0x41, 0x30, 0x41, 0x82, 0x93, 0xC4, 0x04, 0x07, 0x20, 0xB0, 0x12, 0x60, 0xF2,
    0x3F, 0x40, 0x0F, 0x00, 0xB0, 0x12, 0x5E, 0xE3, 0x30, 0x41, 0xB0, 0x12, 0x8E, 0xFC, 0xB0, 0x12, 0xB6, 0xF0, 0x92, 0x93, 0xC6, 0x04, 0x55, 0x24, 0xB0, 0x12,
    0x62, 0xEA, 0xB0, 0x12, 0x8C, 0xEA, 0xB0, 0x12, 0xC0, 0xEA, 0x0F, 0x93, 0x02, 0x24, 0x82, 0x43, 0xE8, 0x04, 0xB2, 0x90, 0xFF, 0x7F, 0xE8, 0x04, 0x04, 0x24,
    0xB2, 0x90, 0xFF, 0x7F, 0xEA, 0x04, 0x3F, 0x24, 0xB0, 0x12, 0x6C, 0xED, 0x0F, 0x93, 0x38, 0x24, 0xB2, 0x90, 0xFF, 0x7F, 0xE8, 0x04, 0x20, 0x24, 0xB2, 0xB0,
    0x00, 0x08, 0x44, 0x04, 0x03, 0x24, 0x92, 0x93, 0xB4, 0x04, 0x13, 0x24, 0xB0, 0x12, 0x64, 0xFD, 0x92, 0x92, 0xB2, 0x04, 0x74, 0x04, 0x01, 0x38, 0x30, 0x41,
    0x82, 0x43, 0xA8, 0x05, 0x82, 0x43, 0xB2, 0x04, 0xB2, 0x40, 0xFF, 0x7F, 0xEE, 0x04, 0xB0, 0x12, 0x60, 0xF2, 0xA2, 0x42, 0x1A, 0x03, 0xF3, 0x3F, 0xB2, 0x40,
    0x09, 0x00, 0xAE, 0x04, 0x92, 0x43, 0xA8, 0x05, 0xE7, 0x3F, 0xB0, 0x12, 0xD8, 0xFC, 0xB0, 0x12, 0xF4, 0xFC, 0xB2, 0xB0, 0x00, 0x10, 0x44, 0x04, 0xD8, 0x27,
    0x92, 0x93, 0xB2, 0x04, 0xD5, 0x23, 0x92, 0x93, 0xA8, 0x05, 0xD2, 0x23, 0xB2, 0x40, 0x0A, 0x00, 0xAE, 0x04, 0x82, 0x43, 0xA8, 0x05, 0xCC, 0x3F, 0xB0, 0x12,
    0x10, 0xFE, 0xC9, 0x3F, 0xB2, 0x40, 0xFF, 0x7F, 0xEE, 0x04, 0xBD, 0x3F, 0xB0, 0x12, 0x60, 0xF2, 0xB2, 0x40, 0xFF, 0x7F, 0xEE, 0x04, 0x82, 0x43, 0xAE, 0x04,
    0xA2, 0x42, 0x1A, 0x03, 0x95, 0x3F, 0xB0, 0x12, 0xFC, 0xE9, 0xB0, 0x12, 0x78, 0xFE, 0xB0, 0x12, 0x38, 0xFD, 0x30, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x16, 0xE0, 0x2C, 0xE0, 0x42, 0xE0, 0x58, 0xE0, 0x6E, 0xE0, 0x84, 0xE0, 0x9A, 0xE0, 0xB0, 0xE0, 0xC6, 0xE0,
    0xDC, 0xE0, 0xF2, 0xE0, 0x08, 0xE1, 0x1E, 0xE1, 0x34, 0xE1, 0x4A, 0xE1, 0x60, 0xE1, 0x76, 0xE1, 0x8C, 0xE1, 0xA2, 0xE1, 0xB8, 0xE1, 0xCE, 0xE1, 0xE4, 0xE1,
    0xFA, 0xE1, 0x44, 0xF4, 0x44, 0xF4, 0x10, 0xE2, 0x44, 0xF4, 0x44, 0xF4, 0x44, 0xF4, 0x44, 0xF4, 0x44, 0xF4,

};

#endif

#ifndef __GH61X_COMMON_FUNCTION_DEFINITION__
#define __GH61X_COMMON_FUNCTION_DEFINITION__

uint8_t spp_is_connect = 0;
//uint8_t gh61x_initon = 0;
//uint8_t gh61x_send_flag = 0;

/**
 * @brief N-millisecond delay function prototype.
 *        This functions should be implemented by user.
 */
void user_delay_ms(uint16_t Nms)
{
    GH61X_EXAMPLE_LOG("user_delay_ms");
    //user code...
    osDelay(1 + Nms);
}

/**
 * @brief I2C initialization function prototype.
 *        This functions should be implemented by user.
 */
void user_i2c_init(void)
{
    GH61X_EXAMPLE_LOG("user_i2c_init");
    //user code...
    xspace_i2c_init();
}

/**
 * @brief GH61X I2C writting operation function prototype.
 *        This functions should be implemented by user.
 */
uint8_t user_i2c_write(uint8_t uchDeviceId, const uint8_t uchWriteBytesArr[], uint16_t usWriteLen)
{
    //GH61X_TRACE(2, "uchDeviceId %d, usWriteLen %d", uchDeviceId, usWriteLen);
    //DUMP8("0x%02x ", uchWriteBytesArr, usWriteLen);

    xspace_i2c_burst_write_01(GH61X_I2C_TYPE, uchDeviceId, (uint8_t *)uchWriteBytesArr, usWriteLen);
    return 0;
}

/**
 * @brief GH61X I2C reading operation function prototype.
 *        This functions should be implemented by user.
 */
uint8_t user_i2c_read(uint8_t uchDeviceId, const uint8_t uchCmddBytesArr[], uint16_t usCmddLen, uint8_t uchReadBytesArr[], uint16_t usMaxReadLen)
{
    //GH61X_TRACE(3, "uchDeviceId %d, usCmddLen %d, usMaxReadLen %d", uchDeviceId, usCmddLen, usMaxReadLen);
    //DUMP8("0x%02x ", uchCmddBytesArr, usCmddLen);

    xspace_i2c_burst_read_01(GH61X_I2C_TYPE, uchDeviceId, (uint8_t *)uchCmddBytesArr, usCmddLen, uchReadBytesArr, usMaxReadLen);
    //DUMP8("0x%02x ", uchReadBytesArr, usMaxReadLen);
    return 0;
}

#if ((__GH61X_USE_GOODIX_APP_BY_BLE__) || (__GH612_USE_GOODIX_APP_BY_BLE__))
/**
 * @brief Ble sending data function prototype.
 *        This functions should be implemented by user.
 */
void user_ble_send_data(uint8_t uchDataBuffArr[], uint8_t uchLen)
{
    //user code...
    GH61X_EXAMPLE_LOG("gh61x tx:");
    GH61X_EXAMPLE_HEXDUMP_DEBUG(uchDataBuffArr, uchLen);
}

/**
 * @brief Handler for BLE debug profile, handling the data from Goodix app.     
 */
void ble_rx_data_handler(uint8_t *buffer, uint8_t length)
{
    GH61X_EXAMPLE_LOG("gh61x rx:");
    GH61X_EXAMPLE_HEXDUMP_DEBUG(buffer, length);

    if ((length == 6) && ((buffer[0] == 0x47) && (buffer[1] == 0x52) && (buffer[2] == 0x41) && (buffer[3] == 0x5A))   //check header
        && (buffer[5] == 0x0A))                                                                                       //check tail
    {
        if (buffer[4] <= DEBUG_CHIP_SELECTION_612) {
            g_debug_chip_selection = buffer[4];
        }
        user_ble_send_data(buffer, 6);   //ack
    } else {
        hal_gh61x_int_deinit();
        switch (g_debug_chip_selection) {
            case DEBUG_CHIP_SELECTION_610:
            case DEBUG_CHIP_SELECTION_611:
#if (__GH61X_USE_GOODIX_APP_BY_BLE__)
            {
                uint8_t ret = GH61X_CommParseHandler(gh61x_ble_comm_type, buffer, length);
                switch (ret) {
                    case 0x10:   //GH61x started in MCU mode by Goodix APP, GH61x would send wearing state and touchkey event to Goodix APP according to actual condition.
                        //user code if needed...
                        break;

                    case 0x11:   //GH61x stoped by Goodix APP.
                        //user code if needed...
                        break;

                    case 0x12:   //GH61x started in app mode by Goodix APP, GH61x would send data packet continuously to Goodix APP in 100Hz.
                    case 0x13:   //the same to 0x12
                        //user code if needed...
                        break;

                    default:
                        break;
                }
                GH61X_MP_Handling();
            }
#endif
            break;

            case DEBUG_CHIP_SELECTION_612:
#if (__GH612_USE_GOODIX_APP_BY_BLE__)
                GH612_CommParseHandler(gh612_ble_comm_type, buffer, length);
#endif
                break;

            default:
                break;
        }
        hal_gh61x_int_init();
        gh61x_adapter_event_process(GH61X_MSG_ID_INT, 0, 0, 0);
    }
}
#endif

static void gh61x_start_test_mode_timer_handler(void const *param)
{
    if (g_IsGH61xStartTestModeCnt) {
        g_IsGH61xStartTestModeCnt = 0;
        osTimerStop(gh61x_start_test_mode_timer);
        osTimerStart(gh61x_start_test_mode_timer, 30 * 1000);
    } else {
        hal_cpu_wake_unlock(HAL_CPU_WAKE_LOCK_USER_8);
        app_sysfreq_req(APP_SYSFREQ_USER_TOUCH_UTT, APP_SYSFREQ_32K);
        if (g_IsGH61xStartTestMode) {
            //TODO
        }
        g_IsGH61xStartTestMode = 0;
        g_IsGH61xSppStartTestMode = 0;
        osTimerStop(gh61x_start_test_mode_timer);
    }
}

#if ((__GH61X_USE_GOODIX_APP_BY_SPP__) || (__GH612_USE_GOODIX_APP_BY_SPP__))
#if (__GH61X_PACKAGE_SET_SPP_ENABLE__)
#define PACKAGE_SET_NUM     (3)
#define PACKAGE_SET_MAX_NUM (PACKAGE_SET_NUM * 30)

uint8_t uchsppstopcmd[4] = {0xc0, 0x22, 0x56, 0x55};
static uint8_t g_gh61x_set_package_uchAllLen = 0;
static uint8_t g_gh61x_package_Count_Num = 0;
static uint8_t g_gh61x_set_package_mode = 0;
static uint8_t uchsppbuffer[PACKAGE_SET_MAX_NUM] = {0};
#endif
void gh61x_spp_is_connected(uint8_t status)
{
    spp_is_connect = status;
}

void user_spp_puts(uint8_t buf[], uint8_t len)
{
    gh61x_adapter_send_data(HAL_TOUCH_EVENT_SEND_DATA, buf, len);
}

/**
 * @brief SPP sending data function prototype.
 */
void user_spp_send_data(uint8_t buf[], uint8_t len)
{
    uint8_t buffer_data[30] = {0};
    buffer_data[0] = 0x47;   //
    buffer_data[1] = 0x44;   //add header
    buffer_data[2] = len;    //
    memcpy(buffer_data + 3, buf, len);
    buffer_data[len + 3] = 0x0A;   //add tail

#if (__GH61X_PACKAGE_SET_SPP_ENABLE__ == 0)
    user_spp_puts(buffer_data, len + 4);   //send a block data, void user_spp_puts(uint8_t buf[], uint8_t len), this function should be implemented by user.
    GH61X_EXAMPLE_LOG("gh61x tx:");
    GH61X_EXAMPLE_HEXDUMP_DEBUG(buffer_data, len + 4);
#else
    if (g_gh61x_set_package_mode == 1) {
        if (memcmp(buf, uchsppstopcmd, len) == 0) {
            g_gh61x_package_Count_Num = 0;
            g_gh61x_set_package_uchAllLen = 0;
            user_spp_puts(buffer_data,
                          len + 4);   //send a block data, void user_spp_puts(uint8_t buf[], uint8_t len), this function should be implemented by user.
            memset(uchsppbuffer, 0, PACKAGE_SET_MAX_NUM);
            GH61X_EXAMPLE_LOG("gh61x tx:");
            GH61X_EXAMPLE_HEXDUMP_DEBUG(buffer_data, len + 4);
            return;
        }

        g_gh61x_package_Count_Num++;
        memcpy(uchsppbuffer + g_gh61x_set_package_uchAllLen, buffer_data, len + 4);
        g_gh61x_set_package_uchAllLen = g_gh61x_set_package_uchAllLen + len + 4;

        if (g_gh61x_package_Count_Num >= PACKAGE_SET_NUM) {
            user_spp_puts(uchsppbuffer, g_gh61x_set_package_uchAllLen);
            g_gh61x_package_Count_Num = 0;
            g_gh61x_set_package_uchAllLen = 0;
            memset(uchsppbuffer, 0, PACKAGE_SET_MAX_NUM);
            GH61X_EXAMPLE_LOG("tx:");
            GH61X_EXAMPLE_HEXDUMP_DEBUG(uchsppbuffer, g_gh61x_set_package_uchAllLen);
        }
    } else {
        user_spp_puts(buffer_data, len + 4);   //send a block data, void user_spp_puts(uint8_t buf[], uint8_t len), this function should be implemented by user.
        GH61X_EXAMPLE_LOG("gh61x tx:");
        GH61X_EXAMPLE_HEXDUMP_DEBUG(buffer_data, len + 4);
    }
#endif
}

/**
 * @brief Handler for SPP debug profile, handling the data from Goodix app.     
 */

void gh61x_spp_rx_data_handler(uint8_t *buffer, uint8_t length)
{
    GH61X_TRACE(3, "%s L%d, length %d", __func__, __LINE__, length);

    if ((buffer[0] == 0x47) && (buffer[1] == 0x44) && (buffer[buffer[2] + 3] == 0x0A)) {
        if (!g_IsGH61xSppStartTestMode) {
            hal_cpu_wake_lock(HAL_CPU_WAKE_LOCK_USER_8);
            app_sysfreq_req(APP_SYSFREQ_USER_TOUCH_UTT, APP_SYSFREQ_52M);
            g_IsGH61xSppStartTestMode = 1;
            osTimerStop(gh61x_start_test_mode_timer);
            osTimerStart(gh61x_start_test_mode_timer, 30 * 1000);
        }
        g_IsGH61xStartTestModeCnt++;
    }

    if ((length == 6) && ((buffer[0] == 0x47) && (buffer[1] == 0x52) && (buffer[2] == 0x41) && (buffer[3] == 0x5A))   //check header
        && (buffer[5] == 0x0A))                                                                                       //check tail
    {
        if (buffer[4] <= DEBUG_CHIP_SELECTION_612) {
            g_debug_chip_selection = buffer[4];
        }
        user_spp_send_data(buffer, 6);   //ack
    } else {
        if ((length > 4) && ((buffer[0] == 0x47) && (buffer[1] == 0x44))   //check header
            && (buffer[2] < 21)                                            //check valid packet len
            && (buffer[buffer[2] + 3] == 0x0A))                            //check tail
        {
            uint8_t *pValidData = buffer + 3;
            uint8_t validLen = buffer[2];

            hal_gh61x_int_deinit();
            switch (g_debug_chip_selection) {
                case DEBUG_CHIP_SELECTION_610:
                case DEBUG_CHIP_SELECTION_611:
#if (__GH61X_USE_GOODIX_APP_BY_SPP__)
                {
                    uint8_t ret = GH61X_CommParseHandler(gh61x_spp_comm_type, pValidData, validLen);

                    switch (ret) {
                        case 0x10:   //GH61x started in MCU mode by Goodix APP, GH61x would send wearing state and touchkey event to Goodix APP according to actual condition.
//user code if needed...
#if (__GH61X_PACKAGE_SET_SPP_ENABLE__)
                            g_gh61x_set_package_mode = 0;
#endif
                            break;

                        case 0x11:   //GH61x stoped by Goodix APP.
                                     //user code if needed...
#if (__GH61X_PACKAGE_SET_SPP_ENABLE__)
                            g_gh61x_set_package_mode = 0;
#endif
                            break;

                        case 0x12:   //GH61x started in app mode by Goodix APP, GH61x would send data packet continuously to Goodix APP in 100Hz.
                        case 0x13:   //the same to 0x12
//user code if needed...
#if (__GH61X_PACKAGE_SET_SPP_ENABLE__)
                            g_gh61x_set_package_mode = 1;
#endif
                            break;

                        default:
#if (__GH61X_PACKAGE_SET_SPP_ENABLE__)
                            g_gh61x_set_package_mode = 0;
#endif
                            break;
                    }

                    GH61X_MP_Handling();
                }
#endif
                break;

                case DEBUG_CHIP_SELECTION_612:
#if (__GH612_USE_GOODIX_APP_BY_SPP__)
                    GH612_CommParseHandler(gh612_spp_comm_type, pValidData, validLen);
#endif
                    break;

                default:
                    break;
            }

            hal_gh61x_int_init();
            gh61x_adapter_event_process(GH61X_MSG_ID_INT, 0, 0, 0);
        }
    }
}
#endif

#if ((__GH61X_USE_GOODIX_DONGLE_BY_UART__) || (__GH612_USE_GOODIX_DONGLE_BY_UART__))
/**
 * @brief Uart sending data function prototype.
 */
void user_uart_send_data(uint8_t buf[], uint8_t len)
{
    //uint8_t index = 0;
    uint8_t buffer_data[30] = {0};
    buffer_data[0] = 0x47;
    buffer_data[1] = 0x44;
    buffer_data[2] = len;
    memcpy(buffer_data + 3, buf, len);
    buffer_data[len + 3] = 0x0A;

    hal_trace_output(buffer_data, len + 4);
    //app_product_test_touch_send_data(buffer_data,len+4);
    //GH61X_TRACE(3, "%s L%d, length %d", __func__, __LINE__, len+4);
    //DUMP8("0x%02x ", buffer_data, len+4);

    //for (index = 0; index < (len + 4); index++)
    //{
    //user_uart_put(buffer_data[index]);//send a single character, void user_uart_put(char ch), this function should be implemented by user.
    //}
}

/**
 * @brief Handler for UART interface, handling the data from Goodix dongle.     
 */
#if 1
void uart_rx_data_handler(uint8_t *buffer, uint8_t length)
{
    GH61X_TRACE(3, "%s L%d, length %d", __func__, __LINE__, length);

    if ((buffer[0] == 0x47) && (buffer[1] == 0x44) && (buffer[buffer[2] + 3] == 0x0A)) {
        if (!g_IsGH61xStartTestMode) {
            hal_cpu_wake_lock(HAL_CPU_WAKE_LOCK_USER_8);
            app_sysfreq_req(APP_SYSFREQ_USER_TOUCH_UTT, APP_SYSFREQ_52M);
            g_IsGH61xStartTestMode = 1;
            osTimerStop(gh61x_start_test_mode_timer);
            osTimerStart(gh61x_start_test_mode_timer, 30 * 1000);
        }
        g_IsGH61xStartTestModeCnt++;
    }

    if ((length == 6) && ((buffer[0] == 0x47) && (buffer[1] == 0x52) && (buffer[2] == 0x41) && (buffer[3] == 0x5A))   //check header
        && (buffer[5] == 0x0A))                                                                                       //check tail
    {
        if (buffer[4] <= DEBUG_CHIP_SELECTION_612) {
            g_debug_chip_selection = buffer[4];
        }
        user_spp_send_data(buffer, 6);   //ack
    } else {
        if ((length > 4) && ((buffer[0] == 0x47) && (buffer[1] == 0x44))   //check header
            && (buffer[2] < 21)                                            //check valid packet len
            && (buffer[buffer[2] + 3] == 0x0A))                            //check tail
        {
            uint8_t *pValidData = buffer + 3;
            uint8_t validLen = buffer[2];

            hal_gh61x_int_deinit();
            switch (g_debug_chip_selection) {
                case DEBUG_CHIP_SELECTION_610:
                case DEBUG_CHIP_SELECTION_611:
#if (__GH61X_USE_GOODIX_DONGLE_BY_UART__)
                {
                    uint8_t ret = GH61X_CommParseHandler(gh61x_uart_comm_type, pValidData, validLen);

                    switch (ret) {
                        case 0x10:   //GH61x started in MCU mode by Goodix APP, GH61x would send wearing state and touchkey event to Goodix APP according to actual condition.
                            //user code if needed...
                            break;

                        case 0x11:   //GH61x stoped by Goodix APP.
                            //user code if needed...
                            break;

                        case 0x12:   //GH61x started in app mode by Goodix APP, GH61x would send data packet continuously to Goodix APP in 100Hz.
                        case 0x13:   //the same to 0x12
                            //user code if needed...
                            break;

                        default:
                            break;
                    }

                    GH61X_MP_Handling();
                }
#endif
                break;

                case DEBUG_CHIP_SELECTION_612:
#if (__GH612_USE_GOODIX_DONGLE_BY_UART__)
                    GH612_CommParseHandler(gh612_uart_comm_type, pValidData, validLen);
#endif
                    break;

                default:
                    break;
            }

            hal_gh61x_int_init();
            gh61x_adapter_event_process(GH61X_MSG_ID_INT, 0, 0, 0);
        }
    }
}

#else

typedef enum {
    COMM_PARSE_STATE_IDLE = 0,
    COMM_PARSE_STATE_GOT_MAGIC_1,
    COMM_PARSE_STATE_GOT_MAGIC_2,
    COMM_PARSE_STATE_GOT_LEN,
    COMM_PARSE_STATE_GOT_DATA,
} EM_COMM_PARSE_STATE;

#define DONGLE_SUPPORT_MAX_LEN 20

typedef enum {
    CHIP_SELECTION_STATE_IDLE = 0,
    CHIP_SELECTION_STATE_GOT_MAGIC_1,
    CHIP_SELECTION_STATE_GOT_MAGIC_2,
    CHIP_SELECTION_STATE_GOT_MAGIC_3,
    CHIP_SELECTION_STATE_GOT_MAGIC_4,
    CHIP_SELECTION_STATE_GOT_CONFIG,
} EM_CHIP_SELECTION_STATE;

uint8_t get_chip_selection_from_data_stream(uint8_t recv_byte)
{
    static uint8_t chip_selection = DEBUG_CHIP_SELECTION_INVALID;
    static EM_CHIP_SELECTION_STATE chip_selection_state = CHIP_SELECTION_STATE_IDLE;

    switch (chip_selection_state) {
        case CHIP_SELECTION_STATE_IDLE:
            if (recv_byte == 0x47) {
                chip_selection_state = CHIP_SELECTION_STATE_GOT_MAGIC_1;
            }
            break;

        case CHIP_SELECTION_STATE_GOT_MAGIC_1:
            if (recv_byte == 0x52) {
                chip_selection_state = CHIP_SELECTION_STATE_GOT_MAGIC_2;
            } else {
                chip_selection_state = CHIP_SELECTION_STATE_IDLE;
            }
            break;

        case CHIP_SELECTION_STATE_GOT_MAGIC_2:
            if (recv_byte == 0x41) {
                chip_selection_state = CHIP_SELECTION_STATE_GOT_MAGIC_3;
            } else {
                chip_selection_state = CHIP_SELECTION_STATE_IDLE;
            }
            break;

        case CHIP_SELECTION_STATE_GOT_MAGIC_3:
            if (recv_byte == 0x5A) {
                chip_selection_state = CHIP_SELECTION_STATE_GOT_MAGIC_4;
            } else {
                chip_selection_state = CHIP_SELECTION_STATE_IDLE;
            }
            break;

        case CHIP_SELECTION_STATE_GOT_MAGIC_4:
            chip_selection = recv_byte;
            chip_selection_state = CHIP_SELECTION_STATE_GOT_CONFIG;
            break;

        case CHIP_SELECTION_STATE_GOT_CONFIG:
            chip_selection_state = CHIP_SELECTION_STATE_IDLE;
            if (recv_byte == 0x0A) {
                uint8_t temp[6] = {0x47, 0x52, 0x41, 0x5A, 0x00, 0x0A};
                temp[4] = chip_selection;
                user_uart_send_data(temp, 6);   //ack
                return chip_selection;
            }
            break;

        default:
            chip_selection_state = CHIP_SELECTION_STATE_IDLE;
            break;
    }

    return DEBUG_CHIP_SELECTION_INVALID;
}
void uart_rx_data_handler(void)
{
    static uint8_t uart_recv_data[DONGLE_SUPPORT_MAX_LEN];
    static uint16_t uart_recv_data_index = 0;
    static uint16_t uart_recv_data_length = 0;
    static EM_COMM_PARSE_STATE parse_state = COMM_PARSE_STATE_IDLE;
    uint8_t chip_selection_temp = DEBUG_CHIP_SELECTION_INVALID;

    uint8_t uart_recv_byte = 0;
    user_uart_get(&uart_recv_byte);   //get a single character, void user_uart_get(char *ch), this function should be implemented by user.

    chip_selection_temp = get_chip_selection_from_data_stream(uart_recv_byte);
    if (chip_selection_temp <= DEBUG_CHIP_SELECTION_612) {
        g_debug_chip_selection = chip_selection_temp;
    }

    switch (parse_state) {
        case COMM_PARSE_STATE_IDLE:
            if (uart_recv_byte == 0x47) {
                parse_state = COMM_PARSE_STATE_GOT_MAGIC_1;
            }
            break;

        case COMM_PARSE_STATE_GOT_MAGIC_1:
            if (uart_recv_byte == 0x44) {
                parse_state = COMM_PARSE_STATE_GOT_MAGIC_2;
            } else {
                parse_state = COMM_PARSE_STATE_IDLE;
            }
            break;

        case COMM_PARSE_STATE_GOT_MAGIC_2:
            if ((uart_recv_byte > 0) && (uart_recv_byte <= DONGLE_SUPPORT_MAX_LEN)) {
                parse_state = COMM_PARSE_STATE_GOT_LEN;
                uart_recv_data_index = 0;
                uart_recv_data_length = uart_recv_byte;
            } else {
                parse_state = COMM_PARSE_STATE_IDLE;
            }
            break;

        case COMM_PARSE_STATE_GOT_LEN:
            uart_recv_data[uart_recv_data_index] = uart_recv_byte;
            uart_recv_data_index++;
            if (uart_recv_data_index >= uart_recv_data_length) {
                parse_state = COMM_PARSE_STATE_GOT_DATA;
            }
            break;

        case COMM_PARSE_STATE_GOT_DATA:
            if (uart_recv_byte == 0x0A) {
                hal_gh61x_int_deinit();

                switch (g_debug_chip_selection) {
                    case DEBUG_CHIP_SELECTION_610:
                    case DEBUG_CHIP_SELECTION_611:
#if (__GH61X_USE_GOODIX_DONGLE_BY_UART__)
                    {
                        uint8_t ret = GH61X_CommParseHandler(gh61x_uart_comm_type, uart_recv_data, uart_recv_data_length);

                        switch (ret) {
                            case 0x10:   //GH61x started in MCU mode by Goodix APP, GH61x would send wearing state and touchkey event to Goodix APP according to actual condition.
                                //user code if needed...
                                break;

                            case 0x11:   //GH61x stoped by Goodix APP.
                                //user code if needed...
                                break;

                            case 0x12:   //GH61x started in app mode by Goodix APP, GH61x would send data packet continuously to Goodix APP in 100Hz.
                            case 0x13:   //the same to 0x12
                                //user code if needed...
                                break;

                            default:
                                break;
                        }

                        GH61X_MP_Handling();
                    }
#endif
                    break;

                    case DEBUG_CHIP_SELECTION_612:
#if (__GH612_USE_GOODIX_DONGLE_BY_UART__)
                        GH612_CommParseHandler(gh612_uart_comm_type, uart_recv_data, uart_recv_data_length);
#endif
                        break;

                    default:
                        break;
                }

                hal_gh61x_int_init();
                gh61x_int_handler();
            }
            parse_state = COMM_PARSE_STATE_IDLE;
            break;

        default:
            parse_state = COMM_PARSE_STATE_IDLE;
            break;
    }
}
#endif

#endif
#endif

/**
 * @brief GH61X reset pin initialization function prototype.
 *        This functions should be implemented by user.
 */
void hal_gh61x_reset_init(void)
{
    GH61X_EXAMPLE_LOG("hal_gh61x_reset_init");
    //user code...
    hal_iomux_init((struct HAL_IOMUX_PIN_FUNCTION_MAP *)&touch_reset_cfg, 1);
#ifdef __XSPACE_UI__
    hal_gpio_pin_set_dir(touch_reset_cfg.pin, HAL_GPIO_DIR_OUT, 0);
#else
    hal_gpio_pin_set_dir(touch_reset_cfg.pin, HAL_GPIO_DIR_OUT, 1);
#endif
}

/**
 * @brief Set GH61X reset pin high function prototype.
 *        This functions should be implemented by user.
 */
void hal_gh61x_reset_high(void)
{
    GH61X_EXAMPLE_LOG("hal_gh61x_reset_high");
    //user code...
    hal_gpio_pin_set(touch_reset_cfg.pin);
}

/**
 * @brief Set GH61X reset pin low function prototype.
 *        This functions should be implemented by user.
 */
void hal_gh61x_reset_low(void)
{
    GH61X_EXAMPLE_LOG("hal_gh61x_reset_low");
    //user code...
    hal_gpio_pin_clr(touch_reset_cfg.pin);
}

/**
 * @brief Get GH61X reset pin level function prototype.
 *        This functions should be implemented by user.
 * @retval 0: low-level; 1: high-level.
 */
uint8_t hal_get_gh61x_reset_level(void)
{
    GH61X_EXAMPLE_LOG("hal_get_gh61x_reset_level");
    //user code...
    return hal_gpio_pin_get_val(touch_reset_cfg.pin);
}

#if (__GH61X_MASS_PRODUCTION_INTERFACE_ENABLE__)
/**
 * @brief GH61X calibration list (backup flash section) writting operation function prototype.
 *        This functions should be implemented by user.
 */
uint8_t user_gh61x_calibration_list_write_flash(const uint8_t uchCalListArr[], uint16_t usWriteLen)
{
    GH61X_EXAMPLE_LOG("user_gh61x_calibration_list_write_flash");
    GH61X_EXAMPLE_HEXDUMP_DEBUG(uchCalListArr, usWriteLen);
    //user code...
#if 1
    if (0) {
        if ((!touch_back_data_write_flash((uint8_t *)uchCalListArr, usWriteLen))
            && (!xspace_backup_touch_back_data_write_flash((uint8_t *)uchCalListArr, usWriteLen))) {
            xra_write_touch_back_data_to_ram((uint8_t *)uchCalListArr, usWriteLen);
            return 1;
        } else {
            return 0;
        }
    } else {
        if (!xra_write_touch_back_data_to_ram((uint8_t *)uchCalListArr, usWriteLen)) {
            return 1;
        } else {
            return 0;
        }
    }
#endif
}

/**
 * @brief GH61X calibration list (backup flash section) reading operation function prototype.
 *        This functions should be implemented by user.
 */
uint8_t user_gh61x_calibration_list_read_flash(uint8_t uchReadBytesArr[], uint16_t usReadLen)
{
    GH61X_EXAMPLE_LOG("user_gh61x_calibration_list_read_flash");
    GH61X_EXAMPLE_HEXDUMP_DEBUG(uchReadBytesArr, usReadLen);
#if 1
    //user code...
    uint8_t tepm_touch_data[GH61X_FLASH_DATA_LENG];
    uint8_t temp_touch_bake_data[GH61X_FLASH_DATA_LENG];
    if (0) {
        if ((usReadLen <= GH61X_FLASH_DATA_LENG) && (uchReadBytesArr != NULL)) {
            if ((touch_back_data_read_flash((uint8_t *)tepm_touch_data, usReadLen) == 0)
                && (xspace_backup_touch_back_data_read_flash((uint8_t *)temp_touch_bake_data, usReadLen) == 0)) {
                if (memcmp(tepm_touch_data, temp_touch_bake_data, usReadLen) == 0) {
                    memcpy(uchReadBytesArr, tepm_touch_data, usReadLen);
                } else {
                    memset(uchReadBytesArr, 0x00, usReadLen);
                    return 0;
                }
                return 1;
            } else {
                return 0;
            }
        } else {
            return 0;
        }
    } else {
        if (!xra_get_touch_back_data_from_ram((uint8_t *)uchReadBytesArr, usReadLen)) {
            return 1;
        } else {
            return 0;
        }
    }
#endif
}

/**
 * @brief GH61X calibration list (main flash section) writting operation function prototype.
 *        This functions should be implemented by user.
 */
uint8_t user_gh61x_main_calibration_list_write_flash(const uint8_t uchCalListArr[], uint16_t usWriteLen)
{
    GH61X_EXAMPLE_LOG("user_gh61x_main_calibration_list_write_flash");
    GH61X_EXAMPLE_HEXDUMP_DEBUG(uchCalListArr, usWriteLen);
    //user code...
#if 1
    if (0) {
        if (!touch_data_write_flash((uint8_t *)uchCalListArr, usWriteLen)) {
            xra_write_touch_data_to_ram((uint8_t *)uchCalListArr, usWriteLen);
            return 1;
        } else {
            return 0;
        }
    } else {
        if (!xra_write_touch_data_to_ram((uint8_t *)uchCalListArr, usWriteLen)) {
            return 1;
        } else {
            return 0;
        }
    }
#endif
}

/**
 * @brief GH61X calibration list (main flash section) reading operation function prototype.
 *        This functions should be implemented by user.
 */
uint8_t user_gh61x_main_calibration_list_read_flash(uint8_t uchReadBytesArr[], uint16_t usReadLen)
{
    GH61X_EXAMPLE_LOG("user_gh61x_main_calibration_list_read_flash");
    GH61X_EXAMPLE_HEXDUMP_DEBUG(uchReadBytesArr, usReadLen);
    //user code...
#if 1
    if (0) {
        if (!touch_data_read_flash((uint8_t *)uchReadBytesArr, usReadLen)) {
            return 1;
        } else {
            return 0;
        }
    } else {
        if (!xra_read_touch_data_from_ram((uint8_t *)uchReadBytesArr, usReadLen)) {
            return 1;
        } else {
            return 0;
        }
    }
#endif
}

/**
 * @brief GH61X calibration list (backup section) writting operation function prototype.
 *        
 */
uint8_t user_gh61x_calibration_list_write(const uint8_t uchCalListArr[], uint16_t usWriteLen)
{
    GH61X_EXAMPLE_LOG("user_gh61x_calibration_list_write");
#if (__GH61X_USE_RAM_SIMULATE_FLASH_ENABLE__)
    memcpy(user_gh61x_calibration_info_in_ram_backup, uchCalListArr, usWriteLen);
    return 1;
#else
    //add real flash write function
    return user_gh61x_calibration_list_write_flash(uchCalListArr, usWriteLen);
#endif
}

/**
 * @brief GH61X calibration list (backup section) reading operation function prototype.
 *        
 */
uint8_t user_gh61x_calibration_list_read(uint8_t uchReadBytesArr[], uint16_t usReadLen)
{
    GH61X_EXAMPLE_LOG("user_gh61x_calibration_list_read");
#if (__GH61X_USE_RAM_SIMULATE_FLASH_ENABLE__)
    memcpy(uchReadBytesArr, user_gh61x_calibration_info_in_ram_backup, usReadLen);
    return 1;
#else
    //add real flash read function
    return user_gh61x_calibration_list_read_flash(uchReadBytesArr, usReadLen);
#endif
}

/**
 * @brief GH61X calibration list (main section) writting operation function prototype.
 *        
 */
uint8_t user_gh61x_main_calibration_list_write(const uint8_t uchCalListArr[], uint16_t usWriteLen)
{
    GH61X_EXAMPLE_LOG("user_gh61x_main_calibration_list_write");
#if (__GH61X_USE_RAM_SIMULATE_FLASH_ENABLE__)
    memcpy(user_gh61x_calibration_info_in_ram_main, uchCalListArr, usWriteLen);
    return 1;
#else
    //add real flash write function
    return user_gh61x_main_calibration_list_write_flash(uchCalListArr, usWriteLen);
#endif
}

/**
 * @brief GH61X calibration list (main section) reading operation function prototype.
 *        
 */
uint8_t user_gh61x_main_calibration_list_read(uint8_t uchReadBytesArr[], uint16_t usReadLen)
{
    GH61X_EXAMPLE_LOG("user_gh61x_main_calibration_list_read");
#if (__GH61X_USE_RAM_SIMULATE_FLASH_ENABLE__)
    memcpy(uchReadBytesArr, user_gh61x_calibration_info_in_ram_main, usReadLen);
    return 1;
#else
    //add real flash read function
    return user_gh61x_main_calibration_list_read_flash(uchReadBytesArr, usReadLen);
#endif
}

void touch_write_flash_befor_shutdown(void)
{
    uint8_t temp_touch_data[GH61X_FLASH_DATA_LENG];
    uint8_t temp_touch_back_data[GH61X_FLASH_DATA_LENG];
    GH61X_TRACE(0, "enter");

    if (!xra_read_touch_data_from_ram(temp_touch_data, GH61X_FLASH_DATA_LENG)) {
        touch_data_write_flash(temp_touch_data, GH61X_FLASH_DATA_LENG);
    }

    if (!xra_get_touch_back_data_from_ram(temp_touch_back_data, GH61X_FLASH_DATA_LENG)) {
        touch_back_data_write_flash(temp_touch_back_data, GH61X_FLASH_DATA_LENG);
    }
}

#endif

static struct HAL_GPIO_IRQ_CFG_T gh61x_irq_cfg;

/**
 * @brief EXTI initialization function prototype.
 *        This functions should be implemented by user.
 */
void hal_gh61x_int_init(void)
{
    static uint8_t init_flag = 0;
    //user code...
    if (!init_flag) {
        init_flag = 1;
        GH61X_EXAMPLE_LOG("hal_gh61x_int_init");
        gh61x_irq_cfg.irq_enable = true;
        gh61x_irq_cfg.irq_debounce = false;
#if defined(__XSPACE_UI__)
        gh61x_irq_cfg.irq_type = HAL_GPIO_IRQ_TYPE_EDGE_SENSITIVE;
#else
        gh61x_irq_cfg.irq_type = HAL_GPIO_IRQ_TYPE_LEVEL_SENSITIVE;
#endif

        gh61x_irq_cfg.irq_handler = gh61x_int_handler;
        //gh61x_irq_cfg.irq_polarity = HAL_GPIO_IRQ_POLARITY_HIGH_RISING;
        gh61x_irq_cfg.irq_polarity = HAL_GPIO_IRQ_POLARITY_HIGH_RISING;
        hal_iomux_init((struct HAL_IOMUX_PIN_FUNCTION_MAP *)&touch_int_cfg, 1);
        //set gpio pulldown
        hal_iomux_set_io_pull_select(touch_int_cfg.pin, HAL_IOMUX_PIN_NOPULL);
        hal_gpio_pin_set_dir(touch_int_cfg.pin, HAL_GPIO_DIR_IN, 0);
        hal_gpio_setup_irq(touch_int_cfg.pin, &gh61x_irq_cfg);
        GH61X_TRACE(0, "done");
    } else {
        hal_gh61x_int_irq_enable(true);
    }
}

void hal_gh61x_int_irq_enable(bool enable)
{

    if (enable == true) {
        gh61x_irq_cfg.irq_enable = true;
    } else {
        gh61x_irq_cfg.irq_enable = false;
    }
    hal_gpio_setup_irq(touch_int_cfg.pin, &gh61x_irq_cfg);
}

/**
 * @brief EXTI deinitialization function prototype.
 *        This functions should be implemented by user.
 */
void hal_gh61x_int_deinit(void)
{
    //user code...
    GH61X_EXAMPLE_LOG("hal_gh61x_int_deinit");
    hal_gh61x_int_irq_enable(false);
}

/**
 * @brief Getting GH61x int pin level function prototype.
 *        This functions should be implemented by user.
 * @retval 0: low-level; 1: high-level.
 */
uint8_t hal_get_gh61x_int_level(void)
{
    GH61X_EXAMPLE_LOG("hal_get_gh61x_int_level");
    //user code...
    return hal_gpio_pin_get_val(touch_int_cfg.pin);
}

void gh61x_int_handler(enum HAL_GPIO_PIN_T pin)
{

    TRACE(2, "%s: level %d", __func__, hal_get_gh61x_int_level());
    if (hal_get_gh61x_int_level()) {
        hal_gh61x_int_irq_enable(false);
        gh61x_adapter_event_process(GH61X_MSG_ID_INT, 0, 0, 0);
    } else {
        TRACE(1, "%s: level is low...", __func__);
    }
}

//static uint8_t gTouchkeyResponsed = 0;
/**
 * @brief EXTI handler for GH61X interrupt.
 */
static EM_WD_STATUS_TYPE wear_status = WD_STATUS_UNKNOWN;
static EM_TK_STATUS_TYPE touchkey_status = TK_NO_OPERA;
static uint32_t prev_ticks_gh61x = 0;

static uint8_t gh61x_loog_key_flag = 0;
static uint8_t gh61x_loogkey5s_timer_cnt = 0;
#if defined(__XSPACE_UI__)
static uint8_t gh61x_loogkey8_timer_cnt = 0;
static void gh61x_loogkey8s_timer_start(void);
static void gh61x_loogkey8s_timer_stop(void);
#endif

static void gh61x_loogkey5s_timer_start(void);
static void gh61x_loogkey5s_timer_stop(void);

static void gh61x_loogkey5s_timer_handler(void const *param)
{
    GH61X_TRACE(2, "%s %d", __func__, gh61x_loogkey5s_timer_cnt);

    gh61x_loogkey5s_timer_cnt++;
    if ((1 == gh61x_loog_key_flag) && (gh61x_loogkey5s_timer_cnt >= 2)) {
        GH61X_TRACE(0, "TK_LONG_TOUCH 5s longlong-touch event");
        gh61x_adapter_report_gesture_event(HAL_TOUCH_EVENT_LONGPRESS_5S);

        gh61x_loogkey5s_timer_stop();
    } else if ((1 == gh61x_loog_key_flag) && (gh61x_loogkey5s_timer_cnt < 2)) {
        gh61x_loogkey5s_timer_start();
    }
}
#if defined(__XSPACE_UI__)
//Note(MK):reserved to implement long press 8s shut down
static void gh61x_loogkey8s_timer_handler(void const *param)
{
    GH61X_TRACE(2, "%s %d", __func__, gh61x_loogkey8_timer_cnt);

    gh61x_loogkey8_timer_cnt++;
    if ((1 == gh61x_loog_key_flag) && (gh61x_loogkey8_timer_cnt == 8)) {
        GH61X_TRACE(0, "TK_LONG_TOUCH 8s longlong-touch event");
        //TODO(Mark)
        gh61x_loogkey8s_timer_stop();
    } else if ((1 == gh61x_loog_key_flag) && (gh61x_loogkey8_timer_cnt < 8)) {
        gh61x_loogkey8s_timer_start();
    }
}

osTimerDef(GH61X_LOOGKEY8S_TIMER, gh61x_loogkey8s_timer_handler);
static osTimerId gh61x_loogkey8s_timer = NULL;

static void gh61x_loogkey8s_timer_start(void)
{
    GH61X_TRACE(1, "%s", __func__);

    osTimerStop(gh61x_loogkey8s_timer);
    osTimerStart(gh61x_loogkey8s_timer, 1000);
}

static void gh61x_loogkey8s_timer_stop(void)
{
    GH61X_TRACE(1, "%s", __func__);

    osTimerStop(gh61x_loogkey8s_timer);
}

#endif
osTimerDef(GH61X_LOOGKEY5S_TIMER, gh61x_loogkey5s_timer_handler);
static osTimerId gh61x_loogkey5s_timer = NULL;

static void gh61x_loogkey5s_timer_start(void)
{
    GH61X_TRACE(1, "%s", __func__);

    osTimerStop(gh61x_loogkey5s_timer);
    osTimerStart(gh61x_loogkey5s_timer, 1000);
}
static void gh61x_loogkey5s_timer_stop(void)
{
    GH61X_TRACE(1, "%s", __func__);

    osTimerStop(gh61x_loogkey5s_timer);
}

void gh61x_int_handler_deal(void)
{
    uint32_t curr_ticks_gh61x = hal_sys_timer_get();//目前时间
    uint32_t diff_ticks_vbus = hal_timer_get_passed_ticks(curr_ticks_gh61x, prev_ticks_gh61x);//所花时长
    POSSIBLY_UNUSED uint16_t Irq_status = 0;
    GH61X_TRACE(2, "%s duration %d ms", __func__, TICKS_TO_MS(diff_ticks_vbus));

    if (hal_get_gh61x_int_level()) {
        int8_t ret = GH61X_IRQHandler();
        Irq_status = GH61X_ReturnIRQStatus();
        GH61X_TRACE(1, "gh61x IRQ status: 0x%x", Irq_status);
//Note(Mark):Extend the save time of the previous touch, combined with long press
#if defined(__XSPACE_UI__)
        if (diff_ticks_vbus > MS_TO_TICKS(5000))
#else
        if (diff_ticks_vbus > MS_TO_TICKS(300))
#endif
        {
            touchkey_status = TK_NO_OPERA;//没有触摸
        }
        prev_ticks_gh61x = curr_ticks_gh61x;

        if ((ret == GH61X_RET_OK) || (ret == GH61X_RET_START_SUCCESS)) {
            GH61X_TRACE(4, "Current: ret %d, gh61x_work_state %d, wear_status %d, touchkey_status %d", ret, gh61x_work_state, wear_status, touchkey_status);

            if (ret == GH61X_RET_START_SUCCESS) {
                if (gh61x_work_state == GH61X_WORK_STATE_STARTING)   //start GH61x successfully.
                {
                    GH61X_TRACE(0, "start GH61x successfully!!!");

                    user_gh61x_work_state_checker_timer_stop();
                    gh61x_work_state = GH61X_WORK_STATE_STARTED;
                }
            }

            GH61X_SendPackage();

#ifdef __HOST_MODE__
            {
                int16_t rawdata[7] = {0};
                if (GH61X_GetRawData(rawdata, 7) == GH61X_RET_OK)   //rawdata valid
                {
                    //print rawdata by host if needed
                }
            }
#endif
            if (GH61X_HasWearingOrTkEventDetected()) {
                GH61X_EXAMPLE_LOG("gh61x wearingOrTk event detected!!!");
                switch (GH61X_GetWearinggStatus()) {
                    GH61X_EXAMPLE_LOG("gh61x wearing status: %d.", GH61X_GetWearingStatus());
                    case WD_STATUS_UNKNOWN:
                        if (wear_status != WD_STATUS_UNKNOWN) {
                            wear_status = WD_STATUS_UNKNOWN;
                        }
                        GH61X_TRACE(0, "WD_STATUS_UNKNOWN");
                        break;

                    case WD_STATUS_WEARING:
                        if (wear_status != WD_STATUS_WEARING) {
                            wear_status = WD_STATUS_WEARING;
                            GH61X_TRACE(0, "WD_STATUS_WEARING");
                            //user code for wearing status
                            //添加触摸模块的调用函数（可以在这里触摸模式检测）
                            gh61x_adapter_report_inear_status(true);
                        }
                        break;

                    case WD_STATUS_UNWEARING:
                        if (wear_status != WD_STATUS_UNWEARING) {
                            wear_status = WD_STATUS_UNWEARING;
                            GH61X_TRACE(0, "WD_STATUS_UNWEARING");
                            //user code for unwearing status
                            gh61x_adapter_report_inear_status(false);
                        }
                        break;
                }

                switch (GH61X_GetTouchkeyStatus()) {
                    case TK_NO_OPERA:

                        if (1 == gh61x_loog_key_flag) {
                            gh61x_loog_key_flag = 0;
                        }

                        if (touchkey_status != TK_NO_OPERA) {
                            touchkey_status = TK_NO_OPERA;
                        }
                        GH61X_TRACE(0, "TK_NO_OPERA");
                        break;

                    case TK_SINGLE_CLICK:
                        if (touchkey_status != TK_SINGLE_CLICK) {
                            touchkey_status = TK_SINGLE_CLICK;
                        }
                        GH61X_TRACE(0, "TK_SINGLE_CLICK");
                        gh61x_adapter_report_gesture_event(HAL_TOUCH_EVENT_CLICK);

                        //添加xspace_gesture_single_earphone_handle()
                        break;

                    case TK_DOUBLE_CLICK:
                        if (touchkey_status != TK_DOUBLE_CLICK) {
                            touchkey_status = TK_DOUBLE_CLICK;
                        }
                        GH61X_TRACE(0, "TK_DOUBLE_CLICK");
                        //user code for double-click event
                        gh61x_adapter_report_gesture_event(HAL_TOUCH_EVENT_DOUBLE_CLICK);
                        break;

                    case TK_TRIPLE_CLICK:
                        if (touchkey_status != TK_TRIPLE_CLICK) {
                            touchkey_status = TK_TRIPLE_CLICK;
                        }
                        GH61X_TRACE(0, "TK_TRIPLE_CLICK");
                        //user code for triple-click event
                        gh61x_adapter_report_gesture_event(HAL_TOUCH_EVENT_TRIPLE_CLICK);
                        break;

                    case TK_UP_SLIDE:
                        if (touchkey_status != TK_UP_SLIDE) {
                            touchkey_status = TK_UP_SLIDE;
                            GH61X_TRACE(0, "TK_UP_SLIDE");
                            //user code for up-slide event
                            gh61x_adapter_report_gesture_event(HAL_TOUCH_EVENT_UP_SLIDE);
                        }
                        break;

                    case TK_DOWN_SLIDE:
                        if (touchkey_status != TK_DOWN_SLIDE) {
                            touchkey_status = TK_DOWN_SLIDE;
                            GH61X_TRACE(0, "TK_DOWN_SLIDE");
                            //user code for down-slide event
                            gh61x_adapter_report_gesture_event(HAL_TOUCH_EVENT_DOWN_SLIDE);
                        }
                        break;

                    case TK_LONG_TOUCH:
                        gh61x_loog_key_flag = 1;
                        gh61x_loogkey5s_timer_cnt = 0;
                        gh61x_loogkey5s_timer_start();
#if defined(__XSPACE_UI__)
                        if (touchkey_status == TK_SINGLE_CLICK)
                            gh61x_loogkey8s_timer_start();
                        else
                            GH61X_TRACE(0, "without previews single touch,no need to timing");
#endif
                        if (touchkey_status != TK_LONG_TOUCH) {
                            touchkey_status = TK_LONG_TOUCH;
                        }
                        GH61X_TRACE(0, "TK_LONG_TOUCH");
                        //user code for long-touch event
                        gh61x_adapter_report_gesture_event(HAL_TOUCH_EVENT_LONGPRESS);
                        break;

                    default:
                        GH61X_TRACE(1, "unknown gesture event(%d)!!!", GH61X_GetTouchkeyStatus());
                        break;
                }
            }
        } else if ((ret == GH61X_RET_ABNORMAL_RESET_ERROR)   // handler for abnormal reset
                   && (!GH61X_IsSystemInMpMode())) {
            GH61X_EXAMPLE_LOG("gh61x abnormal reset!");
            g_gh61x_start_retry_cnt = 0;
            GH61X_Exception_Handling();
        }
    } else {
        GH61X_TRACE(0, "INT level is low, skip ...");
    }
    hal_gh61x_int_irq_enable(true);
}

#if (__GH61X_NEW_CONFIGURATION_ENABLE__)
/**
 * @brief This is a register configuration array example, only used when new 
 * 	      register configuration is needed
 */
#if 0
const unsigned char g_gh61x_RegConfigArr[] = 
{
    0x47, 0x52, 0x41, 0x5A, //Magic Number
    1,                      // len of registers need to config
    
    /* reg addr , reg data */
    0x03,0x60, 0x80,0x00,   // 1. set GH61X INT as level mode.
};
#else
const unsigned char g_gh61x_RegConfigArr[] = {
    0x47,
    0x52,
    0x41,
    0x5A,
    26,
    0x01,
    0xac,
    0x00,
    0x01,
    0x03,
    0x60,
    0x80,
    0x00,
    0x02,
    0x04,
    0x0f,
    0xff,
    0x02,
    0x06,
    0x08,
    0x00,
    0x00,
    0x44,
    0x23,
    0x10,
    0x00,
    0x46,
    0x76,
    0x45,
    0x00,
    0x5c,
    0x05,
    0x05,
    0x00,
    0x5e,
    0x17,
    0x05,
    0x00,
    0x60,
    0x17,
    0x17,
    0x00,
    0x62,
    0x00,
    0x17,
    0x00,
    0x64,
    0x00,
    0x00,
    0x00,
    0x66,
    0x74,
    0x44,
    0x00,
    0x68,
    0x77,
    0x77,
    0x00,
    0x6a,
    0x00,
    0x77,
    0x00,
    0x86,
    0x57,
    0x77,
    0x00,
    0x88,
    0x07,
    0x57,
    0x04,
    0x4a,
    0x00,
    0x64,
    0x04,
    0x4c,
    0x01,
    0x90,
    0x04,
    0x62,
    0x07,
    0x01,
    0x04,
    0x6a,
    0x01,
    0x90,
    0x04,
    0x6e,
    0x01,
    0x2c,
    0x04,
    0x80,
    0x0A,
    0x06,
    0x04,
    0x88,
    0x20,
    0x33,   //S0N
    0x04,
    0x8a,
    0x20,
    0x43,   //S1N
#if defined(__XSPACE_UI__)
    //Note(Mark):touch detect mode using seperate mode
    0x04,
    0x40,
    0x01,
    0xF3,
#else
    0x04, 0x40, 0x02, 0xF3,
#endif
    0x04,
    0x64,
    0x64,
    0xFF,
};

#endif
#endif

#if (__GH61X_HOST_VERSION_REGISTER__)
/**
 * @brief This is a host software version array, used when 
 * 	      register host software vcersion is needed
 * @note  User buffer max length is 16
          Host software version Transmit in ASCII
          Host software version end with '\0' 
 */
#define HOST_VERSION_MAX_LENGTH (16)
static char HostSoftwareVerArr[HOST_VERSION_MAX_LENGTH] = {0};
#endif

#if (__GH61X_BLE_MAC_INFO_REGISTER__)
/**
 * @brief This is a BLE Mac information array, used when 
 * 	      register host software vcersion is needed
 * @note  User buffer length is 6
          Blutooth MAC information Transmit in Bid Endian
 */
#define MAC_INFO_LENGTH (16)
static uint8_t BtMacInfoArr[MAC_INFO_LENGTH] = {0};
extern void factory_section_original_btaddr_get(uint8_t *btAddr);

void hal_get_Bt_Mac_Info(void)
{
    //user code
    //get ble mac information and update the BLE Mac information array: BtMacInfoArr[]
    uint8_t bt_mac_addr[6];
    factory_section_original_btaddr_get(BtMacInfoArr);
    for (uint8_t i = 0; i < 6; i++) {
        bt_mac_addr[i] = BtMacInfoArr[5 - i];
    }
    memset(BtMacInfoArr, 0, MAC_INFO_LENGTH);
    memcpy(BtMacInfoArr, bt_mac_addr, 6);
}

#endif

uint16_t GH61X_get_chipid(void)
{
    uint8_t read_reg[2] = {0x03, 0xfe};
    uint8_t read_val[2] = {0};
    uint8_t write_reg_cmd[4] = {0x80, 0x00, 0x00, 0x01};

    user_i2c_write(0x08, write_reg_cmd, 4);
    user_i2c_read(0x08, read_reg, 2, read_val, 2);   //chipid 0x00A1
    drv_gh61x_chipid = read_val[0] << 8 | read_val[1];
    GH61X_TRACE(1, "chipid:0x%x", read_val[0] << 8 | read_val[1]);
    return (read_val[0] << 8 | read_val[1]);
}

/**
 * @brief GH61X ctrl library initialization.
 * @note  Only called once after system power on. 
 */
int GH61X_Ctrl_init(void)
{
    int init_ret = 0;
    int8_t ret_error_code = 0;
#if (__GH61X_CALIBRATION_ENABLE__)
    int8_t ret;
#endif
#if (__GH61X_HOST_VERSION_REGISTER__)
    int8_t hostsoftware_ret = 0;
    uint8_t VerLength = 0;
#endif

    user_delay_ms(30);
    /*0 (optional) Get GH61X Ctrl Library Version. */
    char gh61xCtrlVersion[15];
    GH61X_GetVersion(gh61xCtrlVersion, 15);
    GH61X_TRACE(1, "gh61x ctrl-lib version: %s", gh61xCtrlVersion);

    /*1.1 Register N-millisecond delay function. */
    GH61X_SetDelayMsCallback(user_delay_ms);
    /*1.2 delay time per frame when send package after reading flash in mp mode. */
#if (__GH61X_READ_FLASH_DELAY_MP_MODE_ENABLE__)
    GH61X_SetCFGDelayMsReadFlashInMP(Xms);   // eg. Xms=1: delay 1ms per frame when send package after reading flash in mp mode.
#endif

    /*2.1 User GPIO init. */
    hal_gh61x_reset_init();
    /*2.2 Register function for setting GH61X reset pin level high and function for setting GH61X reset pin level low. */
    GH61X_SetResetPinHandler(hal_gh61x_reset_high, hal_gh61x_reset_low);
    /*2.3 Register function for getting GH61X reset pin level */
    GH61X_SetReadResetPinLevel(hal_get_gh61x_reset_level);
    /*2.3 Reset GH61X. */
    GH61X_Reset();
    user_delay_ms(30);

    /*3.1 User I2C init. */
    user_i2c_init();
    /*3.2 Register function for I2C writting operation and function for I2C reading operation. */
    GH61X_SetI2cRW(user_i2c_write, user_i2c_read);
    /*3.3 Set GH61x I2C device ID. */
#if (__GH61X_CHIP_SELECTION__ == DEBUG_CHIP_SELECTION_610)
    GH61X_SetI2cDeviceId(0x08);   //GH610(0x08); GH611(0x18); GH612(0x3c); GH613(0x44)
#endif

    /*4 (optional) Register function for writting and reading calibration list */
#if (__GH61X_MASS_PRODUCTION_INTERFACE_ENABLE__)
    GH61X_SetCalibrationListRW(user_gh61x_main_calibration_list_write, user_gh61x_main_calibration_list_read);
    GH61X_SetBackupCalibrationListRW(user_gh61x_calibration_list_write, user_gh61x_calibration_list_read);
#endif

    /*5 (optional) Register address of GH61X inner MCU firmware. */
#if (__GH61X_FIRMWARE_PATCH_ENABLE__)
    GH61X_SetFirmwareAddress(GH61X_PATCH_ADDR);
#endif

    GH61X_TRACE(1, "gh61x firmware version: 0x%x", GH61X_GetFirmwareVersion());

#if (__GH61X_SWITCH_CHANNEL_ENABLE__)
    GH61X_DisableTkWhenIEDSampling(0);
#endif
    //get chipid
    GH61X_get_chipid();
    ret_error_code = GH61X_Init();
    /*6. Init GH61X chip. */
    if (GH61X_RET_OK != ret_error_code) {
        GH61X_TRACE(1, "gh61x init error code: %d", ret_error_code);
        init_ret = -1;
        return init_ret;
    }
#if (__GH61X_MASS_PRODUCTION_INTERFACE_ENABLE__)
    uint8_t temp_touch_data[GH61X_FLASH_DATA_LENG];
    uint8_t temp_touch_back_data[GH61X_FLASH_DATA_LENG];
    //hal_gh61x_int_init ( false );
    if (!touch_data_read_flash(temp_touch_data, GH61X_FLASH_DATA_LENG)) {
        xra_write_touch_data_to_ram(temp_touch_data, GH61X_FLASH_DATA_LENG);
    }

    if (!touch_back_data_read_flash(temp_touch_back_data, GH61X_FLASH_DATA_LENG)) {
        xra_write_touch_back_data_to_ram(temp_touch_back_data, GH61X_FLASH_DATA_LENG);
    }

    xspace_interface_register_write_flash_befor_shutdown_cb(WRITE_TOUCH_TO_FLASH, touch_write_flash_befor_shutdown);
#endif

    /*7. (optional) Load register config. */
#if (__GH61X_NEW_CONFIGURATION_ENABLE__)
    GH61X_LoadConfig((uint8_t *)g_gh61x_RegConfigArr);
#endif

    /*8.1 (optional) enable normalization function if needed. */
#if (__GH61X_NORMALIZATION_TARGET_SET_ENABLE__)
    GH61X_SetOldNormalizationInfo(GH61X_FUNCTION_SWITCH_ENABLE, 24, 24);   // eg:IED int_num normalize to 24
#endif

    /*8.2 (optional) update configuration from calibration list in flash. */
#if (__GH61X_CALIBRATION_ENABLE__)
    ret = GH61X_Calibration();
    switch (ret) {
        case GH61X_RET_FUN_NOT_REGISTERED_ERROR:
            //
            GH61X_TRACE(0, "load calib-parameter in init: GH61X_RET_FUN_NOT_REGISTERED_ERROR");
            break;

        case GH61X_RET_GENERIC_ERROR:
            //
            GH61X_TRACE(0, "load calib-parameter in init: GH61X_RET_GENERIC_ERROR");
            break;

        case GH61X_RET_OK:
            //
            GH61X_TRACE(0, "load calib-parameter in init: GH61X_RET_OK");
            break;

        default:
            break;
    }
#endif

        /*8.3 (optional) enable fast self-calibration if needed. */
#if (__GH61X_FAST_CALIBRATION_ENABLE__)
    GH61X_SetOffsetSelfLearnOverAllCountInChargingBox(10);   // eg:fast offset learning in box in the first 10 times
#endif

    /*9. User EXTI init. Setup External INT for GH61X INT pin. */
    hal_gh61x_int_init();
    GH61X_SetReadIntPinLevel(hal_get_gh61x_int_level);

    /*10 (optional) setup Ble(or other.) send data function. */
#if (__GH61X_USE_GOODIX_APP_BY_BLE__)
    gh61x_ble_comm_type = GH61X_SetSendDataFunc(user_ble_send_data);
#endif
#if (__GH61X_USE_GOODIX_APP_BY_SPP__)
    gh61x_spp_comm_type = GH61X_SetSendDataFunc(user_spp_send_data);
#endif
#if (__GH61X_USE_GOODIX_DONGLE_BY_UART__)
    gh61x_uart_comm_type = GH61X_SetSendDataFunc(user_uart_send_data);
#endif

    /*11 (optional) register BLE MAC and host software version to gh61x. */
#if (__GH61X_HOST_VERSION_REGISTER__)
    VerLength = sizeof(HostSoftwareVerArr);
    hostsoftware_ret = GH61X_SetHostSoftwareVer(HostSoftwareVerArr, VerLength);
    GH61X_TRACE(1, "hostsoftware_ret = %d", hostsoftware_ret);
#endif

#if (__GH61X_BLE_MAC_INFO_REGISTER__)
    hal_get_Bt_Mac_Info();
    GH61X_TRACE(0, "Blutooth MAC is");
    DUMP8("0x%02x ", BtMacInfoArr, 6);
    GH61X_SetBtMacInfo(BtMacInfoArr);
#endif

    if (NULL == gh61x_work_state_checker)
        gh61x_work_state_checker = osTimerCreate(osTimer(GH61X_WORK_STATE_CHECKER_TIMER), osTimerOnce, 0);

#if __GH61X_INT_POLLING__
    if (NULL == gh61x_int_polling_timer)
        gh61x_int_polling_timer = osTimerCreate(osTimer(GH61X_INT_POLLING_TIMER), osTimerPeriodic, 0);
#endif

    if (NULL == gh61x_start_test_mode_timer)
        gh61x_start_test_mode_timer = osTimerCreate(osTimer(GH61X_START_TEST_MODE_TIMER), osTimerOnce, 0);

    if (NULL == gh61x_loogkey5s_timer)
        gh61x_loogkey5s_timer = osTimerCreate(osTimer(GH61X_LOOGKEY5S_TIMER), osTimerOnce, 0);

#if defined(__XSPACE_UI__)
    if (NULL == gh61x_loogkey8s_timer)
        gh61x_loogkey8s_timer = osTimerCreate(osTimer(GH61X_LOOGKEY8S_TIMER), osTimerOnce, 0);
#endif

    GH61X_TRACE(0, "end !!!");
    return init_ret;
}

/**
 * @brief Start GH61X detection in application layer.
 */
int8_t GH61X_Application_Start(void)
{
    int8_t ret;
    g_gh61x_start_retry_cnt = 0;

    ret = GH61X_Start();
#if defined(__INEAR_DETECTION_USE_TOUCH__)
    GH61X_EnableInEarDetection();
#endif
    gh61x_work_state = GH61X_WORK_STATE_STARTING;
    user_gh61x_work_state_checker_timer_start();
#if (__GH61X_INT_POLLING__)
    user_gh61x_int_polling_timer_start();
#endif
    GH61X_EXAMPLE_LOG("gh61x starting");
    return ret;
}

#ifdef __HOST_MODE__
/**
 * @brief Get rawdata for debugging in application layer.
 */
void GH61X_Debug_Start(void)
{
#if (__GH61X_SAMPLERATE_CONFIG__)
    GH61X_SetSampleRateType(enumSampleRate);
#endif
    GH61X_AppMode_Start(1);
}
#endif

/**
 * @brief Stop GH61X detection in application layer.
 */
int8_t GH61X_Application_Stop(void)
{
    int8_t ret;
#if (__GH61X_INT_POLLING__)
    user_gh61x_int_polling_timer_stop();
#endif
    user_gh61x_work_state_checker_timer_stop();

    ret = GH61X_Stop();
    gh61x_work_state = GH61X_WORK_STATE_STOPPED;
    GH61X_EXAMPLE_LOG("gh61x stopped");
    return ret;
}

#define GH61X_ABNORMAL_RESET_RETRY_CNT_MAX 100
/**
 * @brief GH61X exception handling.
 */
void GH61X_Exception_Handling(void)
{
    static uint8_t gAbnormalRstRetryCnt = 0;

    gAbnormalRstRetryCnt = 0;   //clear retry times counter

exception_reset_retry:
    //step1: reset GH61X
    GH61X_EXAMPLE_LOG("exception_reset_retry: %d!", gAbnormalRstRetryCnt);
    GH61X_Reset();
    user_delay_ms(30);

    //step2. re-init GH61X
    if (GH61X_RET_OK != GH61X_Init()) {
        if (gAbnormalRstRetryCnt < GH61X_ABNORMAL_RESET_RETRY_CNT_MAX) {
            gAbnormalRstRetryCnt++;
            goto exception_reset_retry;
        }
        return;
    }

#if (__GH61X_NEW_CONFIGURATION_ENABLE__)
    GH61X_LoadConfig((uint8_t *)g_gh61x_RegConfigArr);
#endif

#if (__GH61X_CALIBRATION_ENABLE__)
    GH61X_Calibration();
#endif

    //step3. start GH61X
    GH61X_Start();
    gh61x_work_state = GH61X_WORK_STATE_STARTING;
    user_gh61x_work_state_checker_timer_start();
    GH61X_TRACE(0, "gh61x starting in Exception Handler!");
}

/**
 * @brief Handling for entering or exiting MP mode.
 *        This functions should partly be implemented by user.
 */
void GH61X_MP_Handling(void)
{
    if ((!g_IsGH61xPreInMpMode) && (GH61X_IsSystemInMpMode() == 1)) {
        GH61X_TRACE(0, "System enter MP mode!");
        g_IsGH61xPreInMpMode = 1;   //update MP-mode flag
        GH61X_Application_Stop();   //stop GH61x for MP test

        //user code for entering MP mode if needed...
    } else if ((g_IsGH61xPreInMpMode) && (GH61X_IsSystemInMpMode() == 0)) {
        GH61X_TRACE(0, "System exit MP mode!");
        g_IsGH61xPreInMpMode = 0;    //update MP-mode flag
        GH61X_Application_Start();   //re-start GH61x

        //user code for exiting MP mode if needed...
    }
}

/**
 * @brief Start a single-shot 500ms timer.
 *        This functions should partly be implemented by user.
 */
static void user_gh61x_work_state_checker_timer_start(void)
{
    GH61X_TRACE(3, "%s, mp %d, state %d", __func__, GH61X_IsSystemInMpMode(), gh61x_work_state);

    // check gh61x work state
    if (GH61X_IsSystemInMpMode() || (gh61x_work_state != GH61X_WORK_STATE_STARTING)) {
        return;
    }

    //user code to start a single-shot 500ms timer...
    osTimerStop(gh61x_work_state_checker);
    osTimerStart(gh61x_work_state_checker, GH61X_TIMER_DELAY);
}

/**
 * @brief Stop the single-shot 500ms timer.
 *        This functions should be implemented by user.
 */
static void user_gh61x_work_state_checker_timer_stop(void)
{
    GH61X_TRACE(1, "%s", __func__);

    //user code to stop the single-shot 500ms timer...
    osTimerStop(gh61x_work_state_checker);
}

/**
 * @brief Handler for the single-shot 500ms timer interrupt.
 */
static void user_gh61x_work_state_checker_handler(void const *param)
{
    gh61x_adapter_event_process(GH61X_MSG_ID_WORK_STATE, 0, 0, 0);
}

void user_gh61x_work_state_checker(void)
{
    GH61X_TRACE(2, "start gh61x failed!!!, mp %d, state %d", GH61X_IsSystemInMpMode(), gh61x_work_state);

    // check gh61x work state
    if (GH61X_IsSystemInMpMode() || (gh61x_work_state != GH61X_WORK_STATE_STARTING)) {
        return;
    }

    GH61X_TRACE(0, "retry to start gh61x handling...");
    g_gh61x_start_retry_cnt++;
    GH61X_TRACE(1, "retry times:%d", g_gh61x_start_retry_cnt);
    if (g_gh61x_start_retry_cnt <= GH61X_START_RETRY_CNT_MAX) {
        GH61X_Exception_Handling();
    }
}

#if __GH61X_INT_POLLING__

/**
 * @brief Start a periodicity timer for checking GH61x interrupt state.
 *        This functions should be implemented by user.
 */
static void user_gh61x_int_polling_timer_start(void)
{
    GH61X_TRACE(1, "%s", __func__);

    //user code to start a periodicity timer...
    osTimerStop(gh61x_int_polling_timer);
    osTimerStart(gh61x_int_polling_timer, GH61X_TIMER_DELAY);
}

/**
 * @brief Stop the periodicity timer for checking GH61x interrupt state.
 *        This functions should be implemented by user.
 */
static void user_gh61x_int_polling_timer_stop(void)
{
    GH61X_TRACE(1, "%s", __func__);

    //user code to stop the periodicity timer...
    osTimerStop(gh61x_int_polling_timer);
}

/**
 * @brief Handler for the checking GH61x interrupt state timer interrupt.
 */
static void user_gh61x_int_polling_handler(void const *param)
{
    if (hal_get_gh61x_int_level()) {
        GH61X_TRACE(0, "polling gh61x start!!!");
        gh61x_adapter_event_process(GH61X_MSG_ID_INT, 0, 0, 0);
    }
}

#endif
#if 0
int main(void)
{
    //user initilization code
    //...

#if (__GH61X_USE_RAM_SIMULATE_FLASH_ENABLE__)
	//Init the ram buffer
	user_gh61x_calibration_list_read_flash(user_gh61x_calibration_info_in_ram_backup,64);
	user_gh61x_main_calibration_list_read_flash(user_gh61x_calibration_info_in_ram_main,64);
#endif

    GH61X_Ctrl_init();

    while(1)
    {
        //1. checking earphone state,
        //2. if earphone state changed, set earphone_state_changed flag to 1
        //   and g_earphone_state to corresponding state
        
        if (earphone_state_changed)//earphone state changed
        {
            earphone_state_changed = 0;
            switch(g_earphone_state)
            {
                case EARPHONE_SLEEP:
                    //do nothing
                    break;
                
                case EARPHONE_STATE_OPEN_BOX:
                    //do nothing
                    break;
                
                case EARPHONE_STATE_TAKE_OUT_BOX:
#if (__HOST_MODE__ == HOST_MODE_APPLICATION)
                    //start GH61x and start a timer for checking whether GH61x start successfully
                    GH61X_Application_Start();
#elif (__HOST_MODE__ == HOST_MODE_DEBUGGING)
					GH61X_Debug_Start();
#endif
                    break;
                
                case EARPHONE_STATE_PUT_IN_BOX:
                    //stop GH61x
                    GH61X_Application_Stop();
                    break;
                
                case EARPHONE_STATE_CLOSE_BOX:
                    //self-cali offset
                    if (gh61x_work_state == GH61X_WORK_STATE_STOPPED)
                    {
						hal_gh61x_int_deinit();
#if (__GH61X_OFFSET_SELFCALIINBOX_CFG_FACTOR_ENABLE__)    
						// usFactorNeg:[1,64];usFactorPos:[1,64]
					    // eg: ret = GH61X_SetOffsetSelfLearnFactorInChargingBox(1,8);
						ret = GH61X_SetOffsetSelfLearnFactorInChargingBox(usFactorNeg,usFactorPoss);
#endif
                        GH61X_SelfCaliInChargingBox();
						hal_gh61x_int_init();
						gh61x_int_handler();
#if (__GH61X_DEBUGINFO_OFFSETSELFCALI_ENABLE__)
						GH61X_GetSelfCalibrationResult(ResultSelfCaliArray);
					    GH61X_EXAMPLE_LOG("SelfCalibrationResult: %d, %d", ResultSelfCaliArray[0], ResultSelfCaliArray[1]);
						GH61X_GetOffsetInfoInSelfCali(OffsetArray);
						GH61X_EXAMPLE_LOG("min-offset: %d, %d", OffsetArray[0], OffsetArray[1]);
						GH61X_EXAMPLE_LOG("inbox-offset: %d, %d", OffsetArray[2], OffsetArray[3]);
						GH61X_EXAMPLE_LOG("real-sc-offset: %d, %d", OffsetArray[4], OffsetArray[5]);
						GH61X_EXAMPLE_LOG("real-fc-offset: %d, %d", OffsetArray[6], OffsetArray[7]);
						GH61X_EXAMPLE_LOG("real-box-diff: %d, %d", OffsetArray[8], OffsetArray[9]);
#endif						
                    }
                    break;

#if (__GH61X_USE_RAM_SIMULATE_FLASH_ENABLE__)	
				//write calibration info back to flash when shutdown
				case EARPHONE_STATE_SHUT_DOWN:
					user_gh61x_calibration_list_write_flash(user_gh61x_calibration_info_in_ram_backup,64);
					user_gh61x_main_calibration_list_write_flash(user_gh61x_calibration_info_in_ram_main,64);
					break;
#endif

#if (__GH61X_SUPER_MP_MODE_ENABLE__)
				case EARPHONE_STATE_ENTER_SUPER_MP_MODE:
					//enter super-mp-mode
					GH61X_EnterSuperMpMode();
					break;
					
				case EARPHONE_STATE_GET_DATA_IN_SUPER_MP_MODE:
					//get data in super-mp-mode
					int16_t buf[3] = {0};
					GH61X_GetDataInSuperMpMode(buf);
					//user code...
					break
				
				case EARPHONE_STATE_EXIT_SUPER_MP_MODE:
					//exit super-mp-mode
					GH61X_ExitSuperMpMode();
					g_gh61x_start_retry_cnt = 0;
					g_gh61x_heartbeat_timeout_cnt = 0;
					GH61X_Exception_Handling();
					break;
#endif 					
		
                default:
                    break;
            }
        }
    }
}
#endif

#endif
